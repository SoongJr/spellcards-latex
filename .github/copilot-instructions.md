# GitHub Copilot Instructions

This repository contains two main parts:
1. A LaTeX project to print spell-cards for a Pathfinder 1e character
2. A Python application in folder `spell_card_generator` to help
   import information from a database to create those cards.

## LaTeX Project

The LaTeX project is responsible for generating the actual spell cards in PDF format.
It takes the structured data provided by the Python application
and formats it according to the LaTeX typesetting system.

### LaTeX Architecture
- **Entry point**: `src/spellcards.tex` - includes spell files and applies cardify layout
- **Templates**: `src/spellcard-templates.tex` - defines spell card layout macros
- **References**: `src/spells/{class}/{level}/{SpellName}.tex` - generated by Python app
- **Output**: `src/out/spellcards.pdf` - generated by LaTeX
- **Workflow**: Python generates `.tex` files → manually include in `spellcards.tex` → compile with `latexmk -view=none -pdf src/spellcards.tex`

## Spell Card Generator Application

A tkinter GUI application with a **multi-step workflow architecture** that guides users through:
Class Selection → Spell Selection → Conflict Resolution → Documentation URLs (QR codes) → Preview & Generate

### Architecture Overview
- **Entry Point**: `main.py` → `app.py` (SpellCardGeneratorApp)
- **Core Components**:
  - `WorkflowCoordinator` (`ui/workflow_coordinator.py`): Orchestrates multi-step workflow
  - `WorkflowState` (`ui/workflow_state.py`): Centralized state management (singleton pattern)
  - `WorkflowNavigator` (`ui/workflow_navigation.py`): Step validation and navigation logic
  - Workflow Steps (`ui/workflow_steps/`): Individual step implementations inheriting from `BaseWorkflowStep`
- **Data Flow**: TSV → `SpellDataLoader` → `SpellFilter` → `WorkflowState` → `LaTeXGenerator` → `.tex` files
- **State Management**: Global singleton `workflow_state` accessed across all workflow components

The project uses Poetry for dependency management and follows
modern Python development practices with a workflow-based GUI.  
The poetry application is to be installed into a virtual environment first (requirements.txt),
before then using poetry to install app dependencies into that same venv.

### Critical Development Environment Setup

⚠️ **MANDATORY**: Every Python/Poetry operation MUST follow this pattern:

```bash
[[ "$(dirname $(pwd))" != latex-spell-cards ]] && cd spell_card_generator && source .venv/bin/activate && poetry run [command]
```

#### Working Directory Challenges
**Problem**: Terminals may start at different locations (repository root or `spell_card_generator`), and reused terminals may already be in the subdirectory.

**Solution**: Use the conditional directory change pattern above:
- `[[ "$(dirname $(pwd))" != latex-spell-cards ]]` - checks if we're NOT in the repo root
- If true, `cd spell_card_generator` navigates to the subdirectory
- If already in `spell_card_generator`, the cd is skipped (no error)
- Always activate `.venv` to ensure the virtual environment is active

This pattern is **idempotent** - it works whether starting from repo root or already in the subdirectory.

#### Application Execution
```bash
[[ "$(dirname $(pwd))" != latex-spell-cards ]] && cd spell_card_generator
source .venv/bin/activate && poetry run spell-card-generator
```

#### Alternative (if needed)
```bash
[[ "$(dirname $(pwd))" != latex-spell-cards ]] && cd spell_card_generator
source .venv/bin/activate && [command]
```

**NEVER run Python commands without:**
1. Ensuring you're in `spell_card_generator` subdirectory (use the conditional pattern above)
2. Activating `.venv` (always run `source .venv/bin/activate`)
3. Using `poetry run` to start the application

### AI Agent Auto-Approval Commands

The following commands are **safe to run automatically** without user confirmation when working in the `spell_card_generator` directory:

#### Code Formatting (Modifies Code)
Consider this safe to run and use freely, especially before linting,
as formatting issues will often show up in linter.  
```bash
# Format code with Black - modifies files but is idempotent and project-standard
cd spell_card_generator && source .venv/bin/activate && poetry run black .
```

#### Code Quality & Testing (Read-Only/Safe)
```bash
# Lint code - always safe, non-destructive
cd spell_card_generator && source .venv/bin/activate && poetry run pylint .

# Run tests - safe, does not modify code
cd spell_card_generator && source .venv/bin/activate && poetry run pytest

# Run tests with coverage - safe, generates reports only
cd spell_card_generator && source .venv/bin/activate && poetry run pytest --cov --cov-report=html

# Type checking - safe, non-destructive
cd spell_card_generator && source .venv/bin/activate && poetry run mypy .

# Verify GUI starts without exceptions (kills after 15s, UI opens after ~10s)
cd spell_card_generator && source .venv/bin/activate && timeout 15s poetry run spell-card-generator
```

#### Commands Requiring User Approval
- `poetry add` / `poetry remove` - modifies dependencies
- `poetry install` - installs/updates packages (generally safe but may take time)
- Full application execution (`spell-card-generator` without timeout) - opens GUI, requires user interaction
- Any file deletion or git operations
- Shell script execution beyond the documented commands

**Note**: Use minimal command syntax (no redundant default arguments like `--score=yes` for pylint)

### Development Guidelines

#### Code Quality Standards
- **Pylint Score**: MUST maintain 10.00/10 and not return non-zero exit code
- **Test Coverage**: Maintain ~55% overall; new features must be well-tested and changes must not decrease coverage
- **Import Style**: Use absolute imports only (`from spell_card_generator.module import ...`)
- **Type Hints**: Required for all function parameters and return values
- **Exception Handling**: Use proper exception chaining (`raise CustomError(...) from e`)
- **Formatting**: Black formatting enforced
- **Testing**: All tests must pass (100% pass rate)

#### UI/UX Principles
- **Single class selection**: Users select exactly one character class (enforced by `single_class_selection.py`)
- **Progressive disclosure**: Later steps only accessible after prerequisites (managed by `WorkflowNavigator`)
- **State persistence**: User input preserved when switching steps (via `workflow_state` singleton)
- **Validation-driven navigation**: Each step validates before allowing progression

### Key Architecture Patterns

#### Workflow State Management
```python
# ALWAYS access state through the singleton
from spell_card_generator.ui.workflow_state import workflow_state

# Read state
selected_class = workflow_state.selected_class
selected_spells = workflow_state.selected_spells

# Update state (triggers UI refresh)
workflow_state.selected_class = "wizard"
```

#### Step Implementation Pattern
All workflow steps inherit from `BaseWorkflowStep` and implement:
- `create_step_content(parent)`: Build UI widgets
- `refresh_ui()`: Update display when workflow state changes
- Call `self.update_navigation()` after state changes to refresh step availability

#### Exception Handling Pattern
```python
# Always chain exceptions with context
try:
    # operation
except SomeError as e:
    raise CustomError("Context message") from e
```

### Common Development Tasks

#### Running the Application
```bash
[[ "$(dirname $(pwd))" != latex-spell-cards ]] && cd spell_card_generator
poetry run spell-card-generator
```

#### Adding Dependencies
```bash
[[ "$(dirname $(pwd))" != latex-spell-cards ]] && cd spell_card_generator
poetry add [--dev] <package-name>
```

#### Code Quality Checks
```bash
# Format code
[[ "$(dirname $(pwd))" != latex-spell-cards ]] && cd spell_card_generator
poetry run black .

# Lint code (maintain 10.00/10 score)
[[ "$(dirname $(pwd))" != latex-spell-cards ]] && cd spell_card_generator
poetry run pylint .

# Type checking
[[ "$(dirname $(pwd))" != latex-spell-cards ]] && cd spell_card_generator
poetry run mypy .

# Run tests
[[ "$(dirname $(pwd))" != latex-spell-cards ]] && cd spell_card_generator
poetry run pytest

# Run tests with coverage
[[ "$(dirname $(pwd))" != latex-spell-cards ]] && cd spell_card_generator
poetry run pytest --cov --cov-report=html

### Testing Strategy

#### Testing Approach
The project uses a **two-tier testing strategy**:

1. **Unit Tests with Mocked tkinter**
   - Mock tkinter widgets to test logic without GUI rendering
   - Test state management, validation, event handlers
   - Located in `tests/ui/` directory
   - Example: `tests/ui/steps/test_preview_generate_step.py`

2. **Integration Tests**
   - Test workflow state transitions end-to-end
   - Verify data flow between components
   - Focus on critical user paths
   - Example: `tests/test_workflow_integration.py`

#### Testing Pattern for tkinter Components
```python
# Mock tkinter to test logic without rendering
def test_step_creation(self, mock_workflow_state):
    with patch('tkinter.Frame'), patch('tkinter.Text'):
        step = PreviewGenerateStep(on_generate=MagicMock())
        step.create_step_content(MagicMock())
        # Assert on logic, not widget rendering
```


### Critical DO NOTs

#### Environment & Execution
- ❌ Run Python commands without proper environment setup
- ❌ Use exclamation marks in commands
- ❌ Modify `.venv/` directory contents
- ❌ Use relative imports (always use absolute)

#### Architecture & Code Quality
- ❌ Cause Pylint to exit non-zero
- ❌ Cause Pytest to exit non-zero
- ❌ Cause test coverage to decrease
- ❌ Create duplicate UI elements

#### UI/UX
- ❌ Allow multiple class selection (enforce single selection)
- ❌ Skip step validation logic
- ❌ Break the progressive disclosure pattern

### Key Integration Points

#### Data Flow Pipeline
1. **Load**: `SpellDataLoader` reads `spell_full.tsv` → DataFrame
2. **Filter**: `SpellFilter` applies class/level/search filters → filtered DataFrame  
3. **Select**: User selections stored in `workflow_state.selected_spells` (list of tuples)
4. **Conflict Check**: `FileScanner` detects existing `.tex` files → `workflow_state.conflicts_detected`
   - Optional: Preserve existing URLs from `.tex` files if user chooses
5. **URL Configuration**: Documentation URLs for QR codes (primary and secondary)
   - Primary URL auto-guessed from spell name (e.g., "Fireball" → URL pattern)
   - Secondary URL can be auto-generated or manually specified
   - URLs validated but user can override with any text
   - Preserved from existing cards if selected during conflict resolution
6. **Generate**: `LaTeXGenerator.generate_cards()` → writes to `src/spells/{class}/{level}/{SpellName}.tex`
7. **Manual Step**: User adds `\input{}` statements to `src/spellcards.tex`

#### Spell Data Structure
```python
# Selected spells stored as List[Tuple[class_name, spell_name, spell_data]]
selected_spells = [
    ("wizard", "Fireball", pd.Series({...})),  # spell_data is a pandas Series
    ("wizard", "Magic Missile", pd.Series({...})),
]
```

#### Custom Exceptions Hierarchy
- `SpellCardError` (base)
  - `DataLoadError` (TSV loading failures)
  - `GenerationError` (LaTeX generation failures)
  - `FilterError` (spell filtering failures)

### Documentation & Context Files
- **project-specific Readme**: In `spell_card_generator/README.md`
- **Entry Point**: Configured in `pyproject.toml` as `spell-card-generator`

### When Making Changes

1. **Test with actual application**: Always run `poetry run spell-card-generator` to verify
2. **Update tests**: Add tests for new functionality; do not decrease overall coverage percentage
3. **Validate workflow**: Ensure step navigation and state updates work correctly
4. **Preserve code quality**: Run linting and maintain 10.00/10 score

### Quick Reference - Most Common Operations

```bash
# Navigate to project directory
cd ./spell_card_generator

# Activate virtual environment
source .venv/bin/activate # On Windows: .venv/Scripts/activate

# Install dependencies
poetry install

# Run application
poetry run spell-card-generator

# Add dependency
poetry add [package]
```

For code quality checks (linting, testing, formatting), see the **AI Agent Auto-Approval Commands** section above.

Remember: This project has reached a certain level of code quality and professional architecture.
The focus now is on completing the remaining workflow steps while maintaining the established standards and patterns.
