# GitHub Copilot Instructions

This repository contains two main parts:
1. A LaTeX project to print spell-cards for a Pathfinder 1e character
2. A Python application in folder `spell_card_generator` to help
   import information from a database to create those cards.

## LaTeX Project

The LaTeX project is responsible for generating the actual spell cards in PDF format.
It takes the structured data provided by the Python application
and formats it according to the LaTeX typesetting system.

### LaTeX Architecture
- **Entry point**: `src/spellcards.tex` - includes spell files and applies cardify layout
- **Templates**: `src/spellcard-templates.tex` - defines spell card layout macros and deck management
- **Modern L3 package**: `src/spellcard-expl3.sty` - expl3/LaTeX3 implementation (modernization in progress)
- **Card files**: `src/spells/{class}/{level}/{SpellName}.tex` - individual spell card definitions (generated by Python app)
- **Deck definitions**: `src/spells/{class}.tex` - defines which spells to print and organizes them into decks
- **Output**: `src/out/spellcards.pdf` - final PDF with spell cards
- **Workflow**: Python generates `.tex` files → user edits `{class}.tex` to organize spells → compile with `latexmk`

### AI Agent Auto-Approval Commands

The following commands are **safe to run automatically** without user confirmation:

```bash
latexindent --cruft=src/out/ --local=src/.latexindent.yaml src/<file>.tex
chktex src/spellcards.tex
# CRITICAL: Always use </dev/null to prevent latexmk from hanging on errors
latexmk -pv- -pdf src/spellcards.tex </dev/null
# Compile and verify LaTeX test PDFs:
latexmk -pv- -pdf src/test-expl3.tex </dev/null
pdftotext src/out/test-expl3.pdf -
pdftotext src/out/test-expl3.pdf - | grep "pattern"
```

If  you wish to parse the output of latex compiler, using `latexmk ... | grep` often breaks the auto-approval detection.
It is often better to discard latexmk's output, decide on the result according to its exit code,
then look at the log file in src/out to see what went wrong.

#### Modern expl3 Package Features

**Spell Inclusion (`\includespell`)**:
The modern interface for including spell card files with optional print control:

```latex
% Include and print a spell card (default)
\includespell{spells/sor/1/MagicMissile.tex}

% Include but don't print (for deck organization without output)
\includespell[noprint]{spells/sor/1/MagicMissile.tex}
\includespell[print=false]{spells/sor/1/MagicMissile.tex}  % equivalent

% Explicitly print (unnecessary, this is the default)
\includespell[print=true]{spells/sor/1/MagicMissile.tex}
```

**Benefits over legacy `\input`**:
- Declarative: Clear intent with options
- Encapsulated: Users don't need to know about `\input`
- Type-safe: Options validated by l3keys
- Error handling: File existence checking
- Extensible: Easy to add future options (deck assignment, filtering, etc.)

**Legacy compatibility**: `\noprint{\input{...}}` still works but is deprecated

**Deck Management**:
```latex
% Start a deck (unnamed for first deck, named for subsequent decks)
\begin{spelldeck}[Combat Spells]
  \includespell{spells/sor/1/MagicMissile.tex}
  \includespell[noprint]{spells/sor/1/Sleep.tex}  % in deck but not printed
\end{spelldeck}
```

**Package Options**:
```latex
% Printer margin configuration (choose one approach)
\usepackage[printer-margin=5mm]{spellcard-expl3}           % uniform margin
\usepackage[printer-margin-x=3mm,printer-margin-y=5mm]{spellcard-expl3}  % separate x/y

% Priority: printer-margin overrides printer-margin-x/printer-margin-y if both specified
```

### LaTeX Development Guidelines

#### Code Quality - chktex Linting

**chktex Usage Guidelines**:
- ✅ **Run on traditional LaTeX2e files**:
  - `src/spellcards.tex` (main document)
  - `src/cardify.tex` (layout code)
  - `src/spellcard-templates.tex` (legacy templates)
  - `src/spells/**/*.tex` (generated spell cards)
  - `src/spells/*.tex` (deck definition files)
  
- ❌ **Do NOT run on expl3/LaTeX3 files** (chktex doesn't understand L3 syntax):
  - `src/*-expl3.sty` (expl3 package files)
  - `src/*-expl3.tex` (expl3 code)
  - `src/test-*.tex` (test documents)
  - Any file containing `\ExplSyntaxOn`/`\ExplSyntaxOff` blocks

**Why exclude expl3 files?**  
chktex predates LaTeX3 and produces false positives on:
- Underscores in function names (e.g., `\l_spellcard_name_tl`)
- Colons in function signatures (e.g., `\cs_new:Npn`)
- Category code changes from `\ExplSyntaxOn`

For expl3 code, rely on:
1. ✅ Successful compilation (if pdflatex compiles, syntax is correct)
2. ✅ Runtime testing with test documents
3. ✅ Manual code review

**MANDATORY**: After before checking changes to LaTeX files, **ALWAYS** run auto-formatter:

```bash
latexindent --cruft=src/out/ --local=src/.latexindent.yaml src/<file>.tex
```

**MANDATORY for traditional LaTeX files**: After implementing LaTeX features or making changes, **ALWAYS** run chktex:

```bash
chktex src/spellcards.tex
```

#### Compilation
```bash
# Standard compilation (from repository root)
# CRITICAL: Always use </dev/null to prevent latexmk from hanging on errors
latexmk -pv- -pdf src/spellcards.tex </dev/null
```

**Critical**: Use `-pv- -pdf` flags (not `-view=none -pdf` which causes conflicts)
**Critical**: Always redirect stdin with `</dev/null` to prevent hanging on compilation errors

**Quality Gates**:
- ✅ **latexmk MUST exit with code 0** (no errors, no warnings)
- ✅ **No LaTeX errors** in log file (lines starting with `!`)
- ✅ **No LaTeX warnings** in log file - we maintain zero warnings
- ✅ **chktex MUST pass** for traditional LaTeX2e files (run before completing work)

**Critical Rules**:
- ✅ while working on LaTeX files, auto-building MUST be disabled in VSCode settings:
  ```json
  "latex-workshop.latex.autoBuild.run": "never"
  ```
  Please make this change at the start of a session and double-check it
  if you encounter your changes to files not being applied.
- ✅ latexmk exit code MUST be 0 (check with `echo $?` after compilation)
- ✅ No warnings allowed - latexmk returns non-zero exit code if warnings exist
- ✅ chktex MUST be run before considering work complete
- ❌ NEVER disable warnings without explicit discussion with the developer
- ❌ Do not use `% chktex-file` or inline `% chktex` comments without approval
- ✅ Fix the underlying issue rather than suppressing warnings
- ✅ All warnings must be fixed before completing work
- ⚠️ Exception: After thorough discussion, specific warnings may be allowed (document in planning docs)

**Common chktex Issues**:
- Unescaped underscores in text (use `\_` or wrap in `\texttt{}`)
- Commands terminated with space (add `{}` after command: `\command{}`)
- Wrong quotation marks (use `` ` `` and `'` instead of `"`)
- Missing `$` in math mode

#### Best Practices

1. **Testing Changes**: Always compile and verify exit code after making changes to templates
   - Run: `latexmk -pv- -pdf src/test-spell.tex </dev/null; echo $?`
   - Must return exit code 0
   - Check log file for errors: `grep "^!" src/out/test-spell.log`
2. **Verify Output**: Check the PDF to ensure layout is correct, especially:
   - Spell markers on right edge
   - Deck labels at top edge
   - Index card formatting
   - QR code at the bottom, left and right respectively
3. **Run Quality Checks**:
   - chktex for traditional LaTeX2e files
   - latexmk exit code must be 0 (which ensures no errors AND no warnings)
   - Verify no LaTeX errors: `grep "^!" src/out/test-spell.log`
   - Verify no warnings: `grep "Warning" src/out/test-spell.log` (should return nothing)
4. **Incremental Development**: Test with small examples before full spell lists
5. **Comments**: Document complex LaTeX macros with clear comments
6. **Compatibility**: As this project is not a module consumed by others, breaking changes can be made freely and addressed in the rest of the document.

#### Common Tasks

**Adding New Template Features**:
1. Implement in `src/spellcard-expl3.sty` (or `src/spellcard-templates.tex` for legacy)
2. Test with example in `src/test-spell.tex`
3. **Compile and verify exit code 0**: `latexmk -pv- -pdf src/test-spell.tex </dev/null; echo $?`
4. **Run chktex and fix all warnings** (for traditional LaTeX2e files only)
5. **Verify no LaTeX errors**: `grep "^!" src/out/test-spell.log`
6. Check PDF output for correct layout
7. Document usage in comments

**Debugging Compilation Issues**:
- Check `src/out/*.log` for detailed error messages (use `grep "^!" src/out/file.log`)
- Look for missing files, undefined commands, or grouping errors
- Verify latexmk exit code: `echo $?` after compilation
- For cardify layout issues, compare with legacy version using `pdftotext -layout`
- Simplify to minimal example to isolate the issue

#### Testing

**Test Files**: `src/test-*.tex` (e.g., `test-expl3.tex`, `test-spell.tex`)
- Create test documents for each package/feature
- Compile with `latexmk -pv- -pdf src/test-expl3.tex`
- Verify output: `pdftotext src/out/test-expl3.pdf - | grep "expected pattern"`
- Update tests when adding features

#### Comparing PDF Output

When making considerable changes, create test files to test the old and new behavior
and compare their output with `pdftotext -layout`:

```bash
# Generate old PDFs to compare
latexmk -pv- -pdf src/test-old.tex </dev/null
latexmk -pv- -pdf src/test-new.tex </dev/null

# Extract text with preserved layout
pdftotext -layout src/out/test-old.pdf src/out/test-old.txt
pdftotext -layout src/out/test-new.pdf src/out/test-new.txt

# Compare outputs
diff -u src/out/test-old.txt src/out/test-new.txt
```

When needed you may dig deeper with more verbose tools:

1. **`pdftotext -bbox`** - When you need exact coordinates:
   ```bash
   pdftotext -bbox src/out/test-new.pdf - | head -200
   ```
   - Outputs HTML/XML with word-level bounding boxes
   - Very verbose (~5000+ lines per page)
   - Use for debugging precise positioning issues

2. **`pdf2svg`** - For visual structure analysis:
   ```bash
   pdf2svg src/out/test-new.pdf src/out/test-page1.svg 1
   ```
   - Converts to SVG (XML format, parseable)
   - Extremely verbose (~4600 lines per page)
   - Use only for TikZ/graphics positioning debugging
   - Can grep for specific elements in XML

**When to Use Each Method**:
- **Regular testing**: `pdftotext -layout` + `diff`
- **Debugging TikZ overlays**: `pdf2svg` for pixel-perfect coordinates
- **Marker/label positioning**: `pdftotext -bbox` for element bounds
- **General layout issues**: `pdftotext -layout` is sufficient

**Output Size Comparison**:
| Method | Lines per Page | Diff Size | Use Case |
|--------|----------------|-----------|----------|
| `pdftotext -layout` | ~90 | ~120 | ✅ Default choice |
| `pdftotext -bbox` | ~5000+ | Massive | Coordinate debugging |
| `pdf2svg` | ~4600 | ~1000+ | Graphics debugging |


## Spell Card Generator Application

A tkinter GUI application with a **multi-step workflow architecture** that guides users through:
Class Selection → Spell Selection → Conflict Resolution → Documentation URLs (QR codes) → Preview & Generate

### Architecture Overview
- **Entry Point**: `main.py` → `app.py` (SpellCardGeneratorApp)
- **Core Components**:
  - `WorkflowCoordinator` (`ui/workflow_coordinator.py`): Orchestrates multi-step workflow
  - `WorkflowState` (`ui/workflow_state.py`): Centralized state management (singleton pattern)
  - `WorkflowNavigator` (`ui/workflow_navigation.py`): Step validation and navigation logic
  - Workflow Steps (`ui/workflow_steps/`): Individual step implementations inheriting from `BaseWorkflowStep`
- **Data Flow**: TSV → `SpellDataLoader` → `SpellFilter` → `WorkflowState` → `LaTeXGenerator` → `.tex` files
- **State Management**: Global singleton `workflow_state` accessed across all workflow components

The project uses Poetry for dependency management and follows
modern Python development practices with a workflow-based GUI.  
**Requirements**: Python 3.10+  
The poetry application is to be installed into a virtual environment first (requirements.txt),
before then using poetry to install app dependencies into that same venv.

### Critical Development Environment Setup

⚠️ **MANDATORY**: Every Python/Poetry operation MUST follow this pattern:

```bash
cd spell_card_generator; source .venv/bin/activate && poetry run [command]
```

#### Working Directory Challenges
**Problem**: Terminals may start at different locations (repository root or `spell_card_generator`), and reused terminals may already be in the subdirectory.

**Solution**: Use the conditional directory change pattern above:
- Opportunistically run `cd spell_card_generator` but ignore the exit code
- If already in `spell_card_generator`, the cd will have no effect (ignore the failure!)
- Always activate `.venv` to ensure the virtual environment is active

This pattern is **idempotent** - it works whether starting from repo root or already in the subdirectory.

#### Application Execution
```bash
cd spell_card_generator; source .venv/bin/activate && poetry run spell-card-generator
```

#### Alternative (if needed)
```bash
cd spell_card_generator; source .venv/bin/activate && [command]
```

**NEVER run Python commands without:**
1. Ensuring you're in `spell_card_generator` subdirectory (use the conditional pattern above)
2. Activating `.venv` (always run `source .venv/bin/activate`)
3. Using `poetry run` to start the application

### AI Agent Auto-Approval Commands

The following commands are **safe to run automatically** without user confirmation when working in the `spell_card_generator` directory:

#### Code Formatting (Modifies Code)
Consider this safe to run and use freely, especially before linting,
as formatting issues will often show up in linter.  
```bash
# Format code with Black - modifies files but is idempotent and project-standard
cd spell_card_generator && source .venv/bin/activate && poetry run black .
```

#### Code Quality & Testing (Read-Only/Safe)
```bash
# Lint code - always safe, non-destructive
cd spell_card_generator && source .venv/bin/activate && poetry run pylint .

# Run tests - safe, does not modify code
cd spell_card_generator && source .venv/bin/activate && poetry run pytest

# Run tests with coverage - safe, generates reports only
cd spell_card_generator && source .venv/bin/activate && poetry run pytest --cov --cov-report=html

# Type checking - safe, non-destructive
cd spell_card_generator && source .venv/bin/activate && poetry run mypy .

# Verify GUI starts without exceptions (kills after 15s, UI opens after ~10s)
cd spell_card_generator && source .venv/bin/activate && timeout 15s poetry run spell-card-generator
```

#### Commands Requiring User Approval
- `poetry add` / `poetry remove` - modifies dependencies
- `poetry install` - installs/updates packages (generally safe but may take time)
- Full application execution (`spell-card-generator` without timeout) - opens GUI, requires user interaction
- Any file deletion or git operations
- Shell script execution beyond the documented commands

**Note**: Use minimal command syntax (no redundant default arguments like `--score=yes` for pylint)

### Development Guidelines

#### Code Quality Standards
- **Python Version**: Requires Python 3.10+
- **Pylint Score**: MUST maintain 10.00/10 and not return non-zero exit code
- **Type Checking**: mypy configured with `check_untyped_defs=true` and `no_implicit_optional=true`
- **Test Coverage**: Maintain ~55% overall; new features must be well-tested and changes must not decrease coverage
- **Import Style**: Use absolute imports only (`from spell_card_generator.module import ...`)
- **Type Hints**: Required for all function parameters and return values (use `Optional[]` for None defaults)
- **Exception Handling**: Use proper exception chaining (`raise CustomError(...) from e`)
- **Formatting**: Black formatting enforced
- **Testing**: All tests must pass (100% pass rate)

#### UI/UX Principles
- **Single class selection**: Users select exactly one character class (enforced by `single_class_selection.py`)
- **Progressive disclosure**: Later steps only accessible after prerequisites (managed by `WorkflowNavigator`)
- **State persistence**: User input preserved when switching steps (via `workflow_state` singleton)
- **Validation-driven navigation**: Each step validates before allowing progression

### Key Architecture Patterns

#### Workflow State Management
```python
# ALWAYS access state through the singleton
from spell_card_generator.ui.workflow_state import workflow_state

# Read state
selected_class = workflow_state.selected_class
selected_spells = workflow_state.selected_spells

# Update state (triggers UI refresh)
workflow_state.selected_class = "wizard"
```

#### Step Implementation Pattern
All workflow steps inherit from `BaseWorkflowStep` and implement:
- `create_step_content(parent)`: Build UI widgets
- `refresh_ui()`: Update display when workflow state changes
- Call `self.update_navigation()` after state changes to refresh step availability

#### Exception Handling Pattern
```python
# Always chain exceptions with context
try:
    # operation
except SomeError as e:
    raise CustomError("Context message") from e
```

### Common Development Tasks

#### Running the Application
```bash
cd spell_card_generator; poetry run spell-card-generator
```

#### Adding Dependencies
```bash
cd spell_card_generator; poetry add [--dev] <package-name>
```

#### Code Quality Checks
```bash
# Format code
cd spell_card_generator; poetry run black .

# Lint code (maintain 10.00/10 pylint score, no flake8 warnings)
cd spell_card_generator; poetry run flake8 . && poetry run pylint .

# Type checking
cd spell_card_generator; poetry run mypy .

# Run tests
cd spell_card_generator; poetry run pytest

# Run tests with coverage
cd spell_card_generator; poetry run pytest --cov --cov-report=html

### Testing Strategy

#### Testing Approach
The project uses a **two-tier testing strategy**:

1. **Unit Tests with Mocked tkinter**
   - Mock tkinter widgets to test logic without GUI rendering
   - Test state management, validation, event handlers
   - Located in `tests/ui/` directory
   - Example: `tests/ui/steps/test_preview_generate_step.py`

2. **Integration Tests**
   - Test workflow state transitions end-to-end
   - Verify data flow between components
   - Focus on critical user paths
   - Example: `tests/test_workflow_integration.py`

#### Testing Pattern for tkinter Components
```python
# Mock tkinter to test logic without rendering
def test_step_creation(self, mock_workflow_state):
    with patch('tkinter.Frame'), patch('tkinter.Text'):
        step = PreviewGenerateStep(on_generate=MagicMock())
        step.create_step_content(MagicMock())
        # Assert on logic, not widget rendering
```


### Critical DO NOTs

#### Environment & Execution
- ❌ Run Python commands without proper environment setup
- ❌ Use exclamation marks in commands
- ❌ Modify `.venv/` directory contents
- ❌ Use relative imports (always use absolute)

#### Architecture & Code Quality
- ❌ Cause Pylint to exit non-zero
- ❌ Cause Pytest to exit non-zero
- ❌ Cause test coverage to decrease
- ❌ Create duplicate UI elements

#### UI/UX
- ❌ Allow multiple class selection (enforce single selection)
- ❌ Skip step validation logic
- ❌ Break the progressive disclosure pattern

### Key Integration Points

#### Data Flow Pipeline
1. **Load**: `SpellDataLoader` reads `spell_full.tsv` → DataFrame
2. **Filter**: `SpellFilter` applies class/level/search filters → filtered DataFrame  
3. **Select**: User selections stored in `workflow_state.selected_spells` (list of tuples)
4. **Conflict Check**: `FileScanner` detects existing `.tex` files → `workflow_state.conflicts_detected`
   - Optional: Preserve existing URLs from `.tex` files if user chooses
5. **URL Configuration**: Documentation URLs for QR codes (primary and secondary)
   - Primary URL auto-guessed from spell name (e.g., "Fireball" → URL pattern)
   - Secondary URL can be auto-generated or manually specified
   - URLs validated but user can override with any text
   - Preserved from existing cards if selected during conflict resolution
6. **Generate**: `LaTeXGenerator.generate_cards()` → writes to `src/spells/{class}/{level}/{SpellName}.tex`
7. **Manual Step**: User adds `\input{}` statements to `src/spellcards.tex`

#### Spell Data Structure
```python
# Selected spells stored as List[Tuple[class_name, spell_name, spell_data]]
selected_spells = [
    ("wizard", "Fireball", pd.Series({...})),  # spell_data is a pandas Series
    ("wizard", "Magic Missile", pd.Series({...})),
]
```

#### Custom Exceptions Hierarchy
- `SpellCardError` (base)
  - `DataLoadError` (TSV loading failures)
  - `GenerationError` (LaTeX generation failures)
  - `FilterError` (spell filtering failures)

### Documentation & Context Files
- **project-specific Readme**: In `spell_card_generator/README.md`
- **Entry Point**: Configured in `pyproject.toml` as `spell-card-generator`

### When Making Changes

1. **Test with actual application**: Always run `poetry run spell-card-generator` to verify
2. **Update tests**: Add tests for new functionality; do not decrease overall coverage percentage
3. **Validate workflow**: Ensure step navigation and state updates work correctly
4. **Preserve code quality**: Run linting and maintain 10.00/10 score

### Quick Reference - Most Common Operations

```bash
# Navigate to project directory
cd ./spell_card_generator

# Activate virtual environment
source .venv/bin/activate # On Windows: .venv/Scripts/activate

# Install dependencies
poetry install

# Run application
poetry run spell-card-generator

# Add dependency
poetry add [package]
```

For code quality checks (linting, testing, formatting), see the **AI Agent Auto-Approval Commands** section above.

Remember: This project has reached a certain level of code quality and professional architecture.
The focus now is on completing the remaining workflow steps while maintaining the established standards and patterns.
