%%
%% This is file `spellcard-expl3.sty'
%%
%% LaTeX3 (expl3) implementation for spell card generation
%% Modern replacement for traditional LaTeX2e macros
%%
%% Copyright (C) 2025 SoongJr
%% License: Open Source (see LICENSE file)
%%

\NeedsTeXFormat{LaTeX2e}
\ProvidesExplPackage
{spellcard-expl3}                    % Package name
{2025/10/25}                         % Release date
{1.0.0}                              % Version
{LaTeX3 implementation for spell cards} % Description

%% ============================================================================
%% Package Dependencies
%% ============================================================================

\RequirePackage{xparse}      % For \NewDocumentCommand and \NewDocumentEnvironment
\RequirePackage{tikz}         % For drawing markers and labels
\RequirePackage{qrcode}       % For QR code generation
\RequirePackage{booktabs}     % For table formatting
\RequirePackage{tabularx}     % For flexible tables
\RequirePackage{longtable}    % For multi-page tables

%% ============================================================================
%% expl3 Programming Environment
%% ============================================================================

\ExplSyntaxOn

%% ============================================================================
%% Module Configuration
%% ============================================================================
%% All internal functions and variables use the prefix: spellcard_
%% Naming conventions:
%%   - Functions: \spellcard_function_name:nn
%%   - Variables: \l_spellcard_variable_name_type or \g_spellcard_variable_name_type
%%   - Constants: \c_spellcard_constant_name_type
%%   - l_ prefix: local scope
%%   - g_ prefix: global scope
%%   - c_ prefix: constant (unchanging)

%% ============================================================================
%% Boolean Variables
%% ============================================================================
%% Modern replacements for \newif constructs

% Flag to control whether a spell card should be printed
% Replaces: \ifprintcard
\bool_new:N \g_spellcard_print_card_bool
\bool_gset_true:N \g_spellcard_print_card_bool

% Flag to detect nested spelldeck environments
% Used for validation to prevent nesting errors
\bool_new:N \g_spellcard_in_deck_bool
\bool_gset_false:N \g_spellcard_in_deck_bool

% Flag to track if printer margins are defined (from cardify.tex)
\bool_new:N \l_spellcard_has_printer_margin_bool
\bool_set_false:N \l_spellcard_has_printer_margin_bool

% Flag for includespell command options (whether to print)
\bool_new:N \l_spellcard_include_print_bool
\bool_set_true:N \l_spellcard_include_print_bool

%% ============================================================================
%% Integer Variables
%% ============================================================================
%% Modern replacements for \newcounter constructs

% Current deck number (0 = unnamed/main deck, 1+ = named decks)
% Replaces: \currentdecknumber counter
\int_new:N \g_spellcard_deck_number_int
\int_gzero:N \g_spellcard_deck_number_int

% QR code counter for tracking codes on current page (max 2)
% Replaces: \qrCode counter
\int_new:N \g_spellcard_qr_code_int
\int_gzero:N \g_spellcard_qr_code_int

% Current spell level for marker positioning
\int_new:N \l_spellcard_spell_level_int
\int_zero:N \l_spellcard_spell_level_int

%% ============================================================================
%% Token List Variables
%% ============================================================================
%% Modern replacements for \newcommand string macros

% Current deck name (empty for deck 0, non-empty for other decks)
% Replaces: \currentdeckname
\tl_new:N \l_spellcard_current_deck_name_tl
\tl_clear:N \l_spellcard_current_deck_name_tl

% Spell card properties - basic identification
\tl_new:N \l_spellcard_class_tl           % Character class (sor, wiz, etc.)
\tl_new:N \l_spellcard_name_tl            % Spell name
\tl_new:N \l_spellcard_school_tl          % School of magic
\tl_new:N \l_spellcard_subschool_tl       % Subschool if applicable
\tl_new:N \l_spellcard_descriptor_tl      % Spell descriptor

% Spell card properties - casting information
\tl_new:N \l_spellcard_casting_time_tl    % Casting time
\tl_new:N \l_spellcard_components_tl      % Components (V, S, M, F, DF)
\tl_new:N \l_spellcard_range_tl           % Range
\tl_new:N \l_spellcard_duration_tl        % Duration
\tl_new:N \l_spellcard_area_tl            % Area of effect
\tl_new:N \l_spellcard_effect_tl          % Effect
\tl_new:N \l_spellcard_targets_tl         % Targets

% Spell card properties - game mechanics
\tl_new:N \l_spellcard_saving_throw_tl    % Saving throw
\tl_new:N \l_spellcard_spell_resistance_tl % Spell resistance
\tl_new:N \l_spellcard_attack_roll_tl     % Attack roll

% URLs for QR codes
\tl_new:N \l_spellcard_url_english_tl     % Primary URL (English)
\tl_new:N \l_spellcard_url_secondary_tl   % Secondary URL (e.g., German)

% Temporary token lists for processing
\tl_new:N \l_spellcard_qr_code_content_tl % Content for QR code being generated
\tl_new:N \l_tmpa_spellcard_tl            % Temporary token list A
\tl_new:N \l_tmpb_spellcard_tl            % Temporary token list B

%% ============================================================================
%% Floating Point Variables
%% ============================================================================
%% For precise positioning calculations

% Marker positioning on right edge (spell level indicator)
\fp_new:N \l_spellcard_marker_position_fp
\fp_zero:N \l_spellcard_marker_position_fp

% Label positioning at top edge (deck name)
\fp_new:N \l_spellcard_label_position_fp
\fp_zero:N \l_spellcard_label_position_fp

% Printer margins (from cardify.tex)
\fp_new:N \l_spellcard_printer_margin_x_fp
\fp_new:N \l_spellcard_printer_margin_y_fp

% QR code positioning
\fp_new:N \l_spellcard_qr_shift_fp
\fp_zero:N \l_spellcard_qr_shift_fp

% Temporary floating point variables
\fp_new:N \l_tmpa_spellcard_fp
\fp_new:N \l_tmpb_spellcard_fp

%% ============================================================================
%% Dimension Variables
%% ============================================================================
%% For layout and spacing calculations

% Card dimensions
\dim_new:N \l_spellcard_card_width_dim
\dim_new:N \l_spellcard_card_height_dim

% Printer margins (converted from FP when needed)
\dim_new:N \l_spellcard_printer_margin_x_dim
\dim_new:N \l_spellcard_printer_margin_y_dim

% Positioning dimensions (calculated from FP)
\dim_new:N \l_spellcard_marker_position_dim
\dim_new:N \l_spellcard_label_position_dim
\dim_new:N \l_spellcard_qr_shift_dim

% Table widths for spell info
\dim_new:N \l_spellcard_first_table_width_dim
\dim_new:N \l_spellcard_second_table_width_dim

%% ============================================================================
%% Package Options
%% ============================================================================
%% Process package options for printer margins

%%% Define keys for package options
\keys_define:nn { spellcard }
{
  % Printer margin in X direction (horizontal)
  printer-margin-x .dim_set:N = \l_spellcard_printer_margin_x_dim,
  printer-margin-x .initial:n = 0pt,

  % Printer margin in Y direction (vertical)  
  printer-margin-y .dim_set:N = \l_spellcard_printer_margin_y_dim,
  printer-margin-y .initial:n = 0pt,

  % Convenience option to set both margins at once
  printer-margin .code:n =
    {
      \dim_set:Nn \l_spellcard_printer_margin_x_dim { #1 }
      \dim_set:Nn \l_spellcard_printer_margin_y_dim { #1 }
    },

  % Unknown option handler
  unknown .code:n =
    {
      \msg_error:nnxx { spellcard } { unknown-option }
      { \l_keys_key_str } { #1 }
    }
}

%%% Process package options
\ProcessKeyOptions [ spellcard ]

%% ============================================================================
%% Property Lists
%% ============================================================================
%% Structured data storage for spell properties

% Main property list for current spell's data
% This replaces the need for 60+ individual \newcommand definitions
\prop_new:N \l_spellcard_spell_props

%% ============================================================================
%% Sequences for Deck Tracking
%% ============================================================================
%% Track which spells belong to each deck for future index card generation

% Global property list: deck_number (as string) -> spell_list_sequence_name
% Each deck's sequence is dynamically created and stored here
\prop_new:N \g_spellcard_decks_prop

% Sequence for the current deck's spells (changes as we enter/exit decks)
% Each item is a property list containing spell metadata
\seq_new:N \g_spellcard_current_deck_spells_seq

% Temporary property list for storing individual spell metadata
\prop_new:N \l_spellcard_spell_metadata_prop

%% ============================================================================
%% Constants
%% ============================================================================

% Maximum QR codes per page
\int_const:Nn \c_spellcard_max_qr_codes_int { 2 }

% Maximum deck columns before wrapping
\int_const:Nn \c_spellcard_max_deck_columns_int { 6 }

% NULL value indicator (used in TSV data)
\tl_const:Nn \c_spellcard_null_value_tl { NULL }

% Marker spacing parameters
\fp_const:Nn \c_spellcard_marker_spacing_fp { 1/16 }
\fp_const:Nn \c_spellcard_marker_offset_fp { 2.5 }

% Label spacing parameters
\fp_const:Nn \c_spellcard_label_spacing_fp { 1/8 }

%% ============================================================================
%% Message System
%% ============================================================================
%% Modern error, warning, and info messages

%%% Package Configuration Errors
\msg_new:nnn { spellcard } { unknown-option }
{
  Unknown~package~option:~'#1'~with~value~'#2'.\\
  Valid~options~are:~printer-margin,~printer-margin-x,~printer-margin-y.
}

%%% Deck Management Errors
\msg_new:nnn { spellcard } { nested-decks }
{
  Nested~spell~decks~are~not~supported.\\
  You~may~have~forgotten~to~close~a~spelldeck~environment.
}

\msg_new:nnn { spellcard } { first-deck-must-be-unnamed }
{
  The~first~spell~deck~must~have~an~empty~name.\\
  Found~deck~name:~'\l_spellcard_current_deck_name_tl'
}

\msg_new:nnn { spellcard } { only-first-deck-unnamed }
{
  Only~the~first~spell~deck~may~have~an~empty~name.\\
  All~subsequent~decks~must~be~named.
}

%%% Spell File Errors
\msg_new:nnn { spellcard } { spell-file-not-found }
{
  Spell~file~not~found:~'#1'\\
  Check~that~the~file~path~is~correct~and~the~file~exists.
}

%%% Layout and Rendering Errors
\msg_new:nnn { spellcard } { too-many-qr-codes }
{
  Too~many~QR~codes~on~page~\int_use:N \c@page.\\
  Maximum~\int_use:N \c_spellcard_max_qr_codes_int~per~page.\\
  Consider~using~\token_to_str:N\clearpage~to~move~code~to~back~face.
}

%%% Data Completeness Warnings
%%% These warn about missing spell properties that may affect rendering

\msg_new:nnn { spellcard } { missing-school }
{
  Spell~'#1':~school~information~is~missing~or~NULL.\\
  This~property~is~required~for~proper~card~formatting.
}

\msg_new:nnn { spellcard } { missing-level }
{
  Spell~'#1':~level~information~is~missing.\\
  Spell~level~markers~cannot~be~drawn~without~this~property.
}

\msg_new:nnn { spellcard } { missing-components }
{
  Spell~'#1':~components~information~is~missing~or~NULL.\\
  Consider~specifying~at~least~'V',~'S',~or~'M'.
}

\msg_new:nnn { spellcard } { missing-casting-time }
{
  Spell~'#1':~casting~time~is~missing~or~NULL.\\
  Standard~action~is~a~common~default.
}

\msg_new:nnn { spellcard } { missing-duration }
{
  Spell~'#1':~duration~is~missing~or~NULL.\\
  This~is~important~tactical~information.
}

\msg_new:nnn { spellcard } { missing-range }
{
  Spell~'#1':~range~is~missing~or~NULL.\\
  Specify~'personal',~'touch',~or~a~distance.
}

%%% Data Quality Warnings
%%% These warn about potentially incorrect or unusual spell properties

\msg_new:nnn { spellcard } { empty-description }
{
  Spell~'#1':~description~appears~to~be~empty.\\
  This~will~result~in~a~nearly~blank~card.
}

\msg_new:nnn { spellcard } { all-targets-null }
{
  Spell~'#1':~area,~effect,~and~targets~are~all~NULL.\\
  At~least~one~of~these~should~be~specified.
}

\msg_new:nnn { spellcard } { suspicious-saving-throw }
{
  Spell~'#1':~saving~throw~is~'NULL'.\\
  Consider~using~'none'~if~no~save~is~allowed.
}

\msg_new:nnn { spellcard } { suspicious-spell-resistance }
{
  Spell~'#1':~spell~resistance~is~'NULL'.\\
  Consider~using~'no'~or~'yes'~explicitly.
}

%%% QR Code Issues
\msg_new:nnn { spellcard } { invalid-url }
{
  QR~code~URL~appears~malformed:~'#1'\\
  QR~codes~work~best~with~valid~http/https~URLs.
}

\msg_new:nnn { spellcard } { empty-qr-url }
{
  Spell~'#1':~QR~code~URL~is~empty~or~NULL.\\
  No~QR~code~will~be~generated~for~this~spell.
}

%%% Informational Messages
\msg_new:nnn { spellcard } { using-default-school }
{
  Spell~'#1':~using~default~school~'Universal'.
}

\msg_new:nnn { spellcard } { skipping-null-attribute }
{
  Spell~'#1':~skipping~NULL~attribute~'#2'.
}

%%% Deck Tracking Messages
\msg_new:nnn { spellcard } { spell-registered }
{
  Spell~'#1'~(level~#2)~registered~in~deck~#3.
}

\msg_new:nnn { spellcard } { deck-created }
{
  Created~deck~#1:~'#2'
}

\msg_new:nnn { spellcard } { spell-outside-deck }
{
  Warning:~Spell~'#1'~included~outside~of~any~deck.\\
  It~will~be~printed~but~not~tracked~for~index~generation.
}%% ============================================================================
%% Utility Functions
%% ============================================================================

%%% Check if printer margins are defined
%%% Priority order:
%%%   1. Package options (printer-margin-x, printer-margin-y)
%%%   2. External commands from cardify.tex (\printermarginx, \printermarginy)
%%%   3. Default to zero (no margins)
%%% Updates \l_spellcard_has_printer_margin_bool and FP variables
\cs_new:Nn \spellcard_check_printer_margins:
{
  % Check if margins were set via package options (non-zero dimensions)
  \bool_lazy_or:nnTF
  { \dim_compare_p:nNn { \l_spellcard_printer_margin_x_dim } > { 0pt } }
  { \dim_compare_p:nNn { \l_spellcard_printer_margin_y_dim } > { 0pt } }
  {
    % Package options were used - convert dimensions to FP
    \bool_set_true:N \l_spellcard_has_printer_margin_bool
    \fp_set:Nn \l_spellcard_printer_margin_x_fp
    { \dim_to_fp:n { \l_spellcard_printer_margin_x_dim } }
    \fp_set:Nn \l_spellcard_printer_margin_y_fp
    { \dim_to_fp:n { \l_spellcard_printer_margin_y_dim } }
  }
  {
    % Package options not used - check for external commands (backwards compatibility)
    \cs_if_exist:NTF \printermarginx
    {
      \bool_set_true:N \l_spellcard_has_printer_margin_bool
      \fp_set:Nn \l_spellcard_printer_margin_x_fp
      { \dim_to_fp:n { \printermarginx } }
      \fp_set:Nn \l_spellcard_printer_margin_y_fp
      { \dim_to_fp:n { \printermarginy } }
      % Also update dimension variables for consistency
      \dim_set:Nn \l_spellcard_printer_margin_x_dim { \printermarginx }
      \dim_set:Nn \l_spellcard_printer_margin_y_dim { \printermarginy }
    }
    {
      % No margins defined anywhere - use zero
      \bool_set_false:N \l_spellcard_has_printer_margin_bool
      \fp_zero:N \l_spellcard_printer_margin_x_fp
      \fp_zero:N \l_spellcard_printer_margin_y_fp
    }
  }
}%%% Check if a value is NULL (used for optional spell properties)
%%% \spellcard_if_not_null:nTF { value } { true-code } { false-code }
\prg_new_conditional:Npnn \spellcard_if_not_null:n #1 { p, T, F, TF }
{
  \str_if_eq:nnTF { #1 } { NULL }
  { \prg_return_false: }
  { \prg_return_true: }
}

%% ============================================================================
%% Positioning Calculations
%% ============================================================================
%%% Calculate marker position on right edge based on spell level
%%% #1 = spell level (0-9 for core spells, can be higher)
%%% Updates \l_spellcard_marker_position_dim
%%% Formula: ((1/16 * mod(level, 10)) * paperheight) + 2.5cm
\cs_new:Nn \spellcard_calculate_marker_position:n
{
  % Calculate modulo 10 to prevent overflow for levels > 9
  % Note: expl3 FP uses "mod" as an infix operator (x mod y), not a function
  \fp_set:Nn \l_tmpa_spellcard_fp { #1 - 10 * floor(#1 / 10) }

  % Calculate position: (1/16 * level_mod) * paperheight + 2.5cm
  \fp_set:Nn \l_spellcard_marker_position_fp
  {
    ( \c_spellcard_marker_spacing_fp * \l_tmpa_spellcard_fp )
    * \dim_to_fp:n { \paperheight }
    + \c_spellcard_marker_offset_fp cm
  }

  % Convert to dimension for TikZ usage
  \dim_set:Nn \l_spellcard_marker_position_dim
  { \fp_to_dim:N \l_spellcard_marker_position_fp }
}%%% Calculate label position at top edge based on deck number
%%% #1 = deck number (1-6, then wraps; 0 has no label)
%%% Updates \l_spellcard_label_position_dim
%%% Formula: ((1/8 * mod(deck-1, 6)) * paperwidth) + offset
%%% Offset is 7mm with printer margins, 15mm without
\cs_new:Nn \spellcard_calculate_label_position:n
{
  % Calculate modulo 6 for deck wrapping (deck-1 because deck 0 has no label)
  % Note: expl3 FP uses "mod" as an infix operator (x mod y), not a function
  \fp_set:Nn \l_tmpb_spellcard_fp { #1 - 1 }
  \fp_set:Nn \l_tmpa_spellcard_fp { \l_tmpb_spellcard_fp - 6 * floor(\l_tmpb_spellcard_fp / 6) }

  % Calculate base position: (1/8 * deck_mod) * paperwidth
  \fp_set:Nn \l_spellcard_label_position_fp
  {
    ( \c_spellcard_label_spacing_fp * \l_tmpa_spellcard_fp )
    * \dim_to_fp:n { \paperwidth }
  }

  % Add offset based on whether printer margins are defined
  \bool_if:NTF \l_spellcard_has_printer_margin_bool
  {
    % With printer margins: add 7mm offset
    \fp_add:Nn \l_spellcard_label_position_fp { 7mm }
  }
  {
    % Without printer margins: add 15mm offset
    \fp_add:Nn \l_spellcard_label_position_fp { 15mm }
  }

  % Convert to dimension for TikZ usage
  \dim_set:Nn \l_spellcard_label_position_dim
  { \fp_to_dim:N \l_spellcard_label_position_fp }
}

%%% Calculate marker x-shift based on printer margins
%%% Returns dimension for TikZ xshift
%%% With printer margins: -7mm
%%% Without printer margins: -12mm (-7mm - 5mm)
\cs_new:Nn \spellcard_get_marker_xshift:
{
  \bool_if:NTF \l_spellcard_has_printer_margin_bool
  { -7mm }
  { -12mm }
}

%%% Calculate marker guide width based on printer margins
%%% Returns dimension for TikZ line drawing
%%% With printer margins: 14mm
%%% Without printer margins: 19mm (14mm + 5mm)
\cs_new:Nn \spellcard_get_marker_guide_width:
{
  \bool_if:NTF \l_spellcard_has_printer_margin_bool
  { 14mm }
  { 19mm }
}

%% ============================================================================
%% QR Code Management System
%% ============================================================================
%%% Modern replacement for \spellcardqr command using expl3
%%% Validates QR code count, calculates positioning based on page parity
%%% and QR code number, then renders using TikZ

%%% Calculate QR code shift based on QR code number
%%% First QR code (index 0): 2cm - placed opposite page number
%%% Second QR code (index 1): 4cm - needs space for page number
%%% Stores result in \l_spellcard_qr_shift_dim
\cs_new:Nn \spellcard_calculate_qr_shift:
{
  \int_compare:nNnTF { \g_spellcard_qr_code_int } = { 0 }
    {
      \dim_set:Nn \l_spellcard_qr_shift_dim { 2cm }
    }
    {
      \dim_set:Nn \l_spellcard_qr_shift_dim { 4cm }
    }
}

%%% Place QR code at south west corner
%%% #1 = QR code content
\cs_new:Nn \spellcard_place_qr_southwest:n
{
  \begin{tikzpicture}[remember~picture,~overlay]
    \node [anchor=south~west,~xshift=\l_spellcard_qr_shift_dim,~yshift=1cm]
    at~(current~page.south~west) { \qrcode{#1} };
  \end{tikzpicture}
}

%%% Place QR code at south east corner
%%% #1 = QR code content
\cs_new:Nn \spellcard_place_qr_southeast:n
{
  \begin{tikzpicture}[remember~picture,~overlay]
    \node [anchor=south~east,~xshift=-\l_spellcard_qr_shift_dim,~yshift=1cm]
    at~(current~page.south~east) { \qrcode{#1} };
  \end{tikzpicture}
}

%%% Process QR code placement on odd pages (page number on right)
%%% #1 = QR code content
\cs_new:Nn \spellcard_qr_code_odd_page:n
{
  \int_case:nn { \g_spellcard_qr_code_int }
  {
    { 0 } { \spellcard_place_qr_southwest:n { #1 } }  % First code: left side
      { 1 } { \spellcard_place_qr_southeast:n { #1 } }  % Second code: right side
  }
}

%%% Process QR code placement on even pages (page number on left)
%%% #1 = QR code content
\cs_new:Nn \spellcard_qr_code_even_page:n
{
  \int_case:nn { \g_spellcard_qr_code_int }
  {
    { 0 } { \spellcard_place_qr_southeast:n { #1 } }  % First code: right side
      { 1 } { \spellcard_place_qr_southwest:n { #1 } }  % Second code: left side
  }
}

%%% Add QR code to current page
%%% #1 = QR code content (URL or text)
%%% Validates maximum 2 codes per page
%%% Calculates position based on page parity and QR code number
\cs_new:Nn \spellcard_add_qr_code:n
{
  % Validate: maximum 2 QR codes per page
  \int_compare:nNnT { \g_spellcard_qr_code_int } > { 1 }
    {
      \msg_error:nn { spellcard } { too-many-qr-codes }
    }

  % Calculate shift distance based on QR code number
  \spellcard_calculate_qr_shift:

  % Place QR code based on page parity
  \int_if_odd:nTF { \value{page} }
  {
    \spellcard_qr_code_odd_page:n { #1 }
  }
  {
    \spellcard_qr_code_even_page:n { #1 }
  }

  % Increment QR code counter
  \int_gincr:N \g_spellcard_qr_code_int
}

%%% Reset QR code counter
%%% Called at the start of each spell card environment
%%% Can also be called manually with \clearpage for testing
\cs_new:Nn \spellcard_reset_qr_counter:
{
  \int_gzero:N \g_spellcard_qr_code_int
}

%% ============================================================================
%% Conditional Logic for Spell Attributes
%% ============================================================================

%%% Print spell attribute only if value is not NULL
%%% #1 = attribute name (label)
%%% #2 = attribute value (content)
%%% Replaces: \ifthenelse{\equal{#2}{NULL}}{}{\textbf{#1:} & #2 \\ \midrule}
\cs_new:Nn \spellcard_attribute:nn
{
  \spellcard_if_not_null:nT { #2 }
  {
    \textbf{#1:} & #2 \\ \midrule
  }
}

%%% Print last spell attribute (always printed, no NULL check)
%%% #1 = attribute name (label)
%%% #2 = attribute value (content)
%%% Replaces: \textbf{#1:} & #2 \\ \bottomrule
\cs_new:Nn \spellcard_attribute_last:nn
{
  \textbf{#1:} & #2 \\ \bottomrule
}

%% ============================================================================
%% Deck Management System
%% ============================================================================

%%% Begin a spell deck
%%% Updates current deck state variables and initializes spell tracking
\cs_new:Nn \spellcard_deck_begin:n
{
% Check for nested decks (error if we're already in a deck)
\bool_if:NTF \g_spellcard_in_deck_bool
{
  \msg_error:nn { spellcard } { nested-decks }
}
{
  % Mark that we're now in a deck
  \bool_gset_true:N \g_spellcard_in_deck_bool
}

% Validate deck naming rules BEFORE setting the name
\int_compare:nNnTF { \g_spellcard_deck_number_int } = { 0 }
{
% First deck must be unnamed
\tl_if_empty:nF { #1 }
{
  \msg_error:nn { spellcard } { first-deck-must-be-unnamed }
}
}
{
% Subsequent decks must be named
\tl_if_empty:nT { #1 }
{
  \msg_error:nn { spellcard } { only-first-deck-unnamed }
}
}

% Set the new deck name (after validation)
\tl_set:Nn \l_spellcard_current_deck_name_tl { #1 }

% Initialize spell tracking for this deck
\seq_gclear:N \g_spellcard_current_deck_spells_seq
}

%%% End a spell deck
%%% Increments deck counter, stores spell list, and clears current deck name
\cs_new:Nn \spellcard_deck_end:
{
  % Store the deck's spell list in the global registry
  % Create a unique sequence for this deck number
  \cs_if_exist:cF { g_spellcard_deck_ \int_use:N \g_spellcard_deck_number_int _spells_seq }
  {
    \seq_new:c { g_spellcard_deck_ \int_use:N \g_spellcard_deck_number_int _spells_seq }
  }

  % Copy current deck's spells to the permanent deck sequence
  \seq_gset_eq:cN { g_spellcard_deck_ \int_use:N \g_spellcard_deck_number_int _spells_seq }
  \g_spellcard_current_deck_spells_seq

  % Store metadata about this deck in property list
  % Format: "deck_N" -> "name={...},count=N"
  \tl_set:Nx \l_tmpa_spellcard_tl
  {
    name={\tl_use:N \l_spellcard_current_deck_name_tl},
    count={\int_eval:n { \seq_count:N \g_spellcard_current_deck_spells_seq }}
  }
  \prop_gput:NVn \g_spellcard_decks_prop
  \l_tmpa_spellcard_tl
  { \tl_use:N \l_tmpa_spellcard_tl }

  % Increment the global deck counter
  \int_gincr:N \g_spellcard_deck_number_int

  % Clear the current deck name to mark we're outside a deck
  \tl_clear:N \l_spellcard_current_deck_name_tl

  % Mark that we're no longer in a deck
  \bool_gset_false:N \g_spellcard_in_deck_bool
}

%% ============================================================================
%% Spell Registration System
%% ============================================================================

%%% Register a spell in the current deck's spell list
%%% #1 = spell file path
%%% #2 = spell class (e.g., "sor", "wiz")
%%% #3 = spell name
%%% #4 = spell level
\cs_new:Nn \spellcard_register_spell:nnnn
{
  % Only register if we're inside a deck
  \tl_if_empty:NF \l_spellcard_current_deck_name_tl
  {
    % Create a property list for this spell's metadata
    \prop_clear:N \l_spellcard_spell_metadata_prop
    \prop_put:Nnn \l_spellcard_spell_metadata_prop { file } { #1 }
    \prop_put:Nnn \l_spellcard_spell_metadata_prop { class } { #2 }
    \prop_put:Nnn \l_spellcard_spell_metadata_prop { name } { #3 }
    \prop_put:Nnn \l_spellcard_spell_metadata_prop { level } { #4 }
    \prop_put:Nnx \l_spellcard_spell_metadata_prop { deck }
    { \int_use:N \g_spellcard_deck_number_int }

    % Serialize the property list to a token list for storage
    % Format: "file={...},class={...},name={...},level={...}"
    \tl_set:Nx \l_tmpa_spellcard_tl
    {
      file={#1},class={#2},name={#3},level={#4}
    }

    % Add to current deck's spell sequence
    \seq_gput_right:NV \g_spellcard_current_deck_spells_seq \l_tmpa_spellcard_tl
  }
}

%%% Extract spell information from file path
%%% Path format: spells/{class}/{level}/{SpellName}.tex
%%% Sets \l_tmpa_spellcard_tl = class, \l_tmpb_spellcard_tl = level, 
%%% \l_spellcard_name_tl = spell name
\cs_new:Nn \spellcard_parse_spell_path:n
{
  % Extract class (between first and second /)
  \tl_set:Nn \l_tmpa_spellcard_tl { #1 }

  % Simple extraction: split on / and get components
  % This is a simplified version - full implementation would use regex
  % For now, we'll extract what we can from the path pattern
  % TODO: Implement full path parsing with regex
}

%% ============================================================================
%% Deck Query Functions
%% ============================================================================
%% Functions to query deck contents - useful for index card generation

%%% Get the number of spells in a specific deck
%%% #1 = deck number
%%% Returns: integer count
\cs_new:Nn \spellcard_get_deck_spell_count:n
{
  \seq_count:c { g_spellcard_deck_ #1 _spells_seq }
}

%%% Get the total number of decks created
\cs_new:Nn \spellcard_get_deck_count:
{
  \int_use:N \g_spellcard_deck_number_int
}

%%% Check if a deck exists
%%% #1 = deck number
\prg_new_conditional:Npnn \spellcard_if_deck_exists:n #1 { p, T, F, TF }
{
  \cs_if_exist:cTF { g_spellcard_deck_ #1 _spells_seq }
  { \prg_return_true: }
  { \prg_return_false: }
}

%%% Map a function over all spells in a deck
%%% #1 = deck number
%%% #2 = inline function to apply to each spell metadata string
%%% Each spell is passed as: file={...},class={...},name={...},level={...}
\cs_new:Nn \spellcard_map_deck_spells:nn
{
  \spellcard_if_deck_exists:nTF { #1 }
  {
    \seq_map_inline:cn { g_spellcard_deck_ #1 _spells_seq } { #2 }
  }
  {
    \msg_warning:nnn { spellcard } { deck-not-found } { #1 }
  }
}

%%% Count spells of a specific level in a deck
%%% #1 = deck number
%%% #2 = spell level to count
\cs_new:Nn \spellcard_count_spells_by_level:nn
{
  \int_zero:N \l_tmpa_int
  \spellcard_map_deck_spells:nn { #1 }
  {
    % Parse the metadata string to check level
    % This is simplified - full implementation would parse the key-value pairs
    \tl_if_in:nnT { ##1 } { level={#2} }
  {
    \int_incr:N \l_tmpa_int
  }
}
\int_use:N \l_tmpa_int
}

%%% Export deck spell list to console (debugging/verification)
%%% #1 = deck number
\cs_new:Nn \spellcard_show_deck:n
{
  \spellcard_if_deck_exists:nTF { #1 }
  {
    \msg_info:nnx { spellcard } { deck-info }
    {
      Deck~#1~contains~\spellcard_get_deck_spell_count:n { #1 }~spells
    }
    \spellcard_map_deck_spells:nn { #1 }
    {
      \msg_info:nnn { spellcard } { spell-info } { ##1 }
    }
  }
  {
    \msg_warning:nnn { spellcard } { deck-not-found } { #1 }
  }
}

%% Add messages for deck queries
\msg_new:nnn { spellcard } { deck-not-found }
{
  Deck~#1~does~not~exist~or~has~not~been~created~yet.
}

\msg_new:nnn { spellcard } { deck-info }
{
  #1
}

\msg_new:nnn { spellcard } { spell-info }
{
  ~~-~#1
}

%% ============================================================================
%% Print Control System
%% ============================================================================

%%% Keys for spell inclusion options
\keys_define:nn { spellcard / includespell }
{
  % Whether to print the spell card (default: true)
  print .bool_set:N = \l_spellcard_include_print_bool,
  print .initial:n = true,
  print .default:n = true,

  % Alias: noprint sets print to false
  noprint .bool_set_inverse:N = \l_spellcard_include_print_bool,
  noprint .default:n = true,
}

%%% Internal function to include a spell file with options
%%% #1 = file path (relative to document root)
\cs_new:Nn \spellcard_include_spell:n
{
  % Save current print state
  \bool_set_eq:NN \l_tmpa_bool \g_spellcard_print_card_bool

  % Set print state based on the 'print' option
  \bool_gset_eq:NN \g_spellcard_print_card_bool \l_spellcard_include_print_bool

  % Check if file exists before including
  \file_if_exist:nTF { #1 }
  {
    \file_input:n { #1 }
  }
  {
    \msg_error:nnn { spellcard } { spell-file-not-found } { #1 }
  }

  % Restore previous print state
  \bool_gset_eq:NN \g_spellcard_print_card_bool \l_tmpa_bool
}

%% ============================================================================
%% Initialization
%% ============================================================================

% Check for printer margins at package load
\AtBeginDocument
{
  \spellcard_check_printer_margins:
}

%% ============================================================================
%% End of expl3 Programming Environment
%% ============================================================================

\ExplSyntaxOff

%% ============================================================================
%% Document-Level Interface (LaTeX2e compatibility)
%% ============================================================================

%%% Spell Deck Environment
%%% Usage: \begin{spelldeck}{name} ... \end{spelldeck}
%%% First deck must have empty name {}, subsequent decks must be named
\ExplSyntaxOn
\NewDocumentEnvironment{spelldeck}{m}
{
  \spellcard_deck_begin:n { #1 }
}
{
  \spellcard_deck_end:
}
\ExplSyntaxOff

%%% Spell Inclusion Command
%%% Usage: 
%%%   \includespell{spells/sor/1/MagicMissile}           % print the spell
%%%   \includespell[noprint]{spells/sor/1/MagicMissile}  % include without printing
%%%   \includespell[print=false]{spells/sor/1/MagicMissile}  % same as noprint
\ExplSyntaxOn
\NewDocumentCommand{\includespell}{O{} m}
{
  % Process options
  \keys_set:nn { spellcard / includespell } { #1 }

  % Include the spell file
  \spellcard_include_spell:n { #2 }
}
\ExplSyntaxOff

%%% Spell Attribute Commands
%%% Modern interface for printing spell attributes with NULL checking
\ExplSyntaxOn

%%% Print a spell attribute (skips if NULL)
%%% Usage: \spellattribute{Range}{25 ft + 5 ft/2 levels}
\NewDocumentCommand{\spellattribute}{m m}
{
  \spellcard_attribute:nn { #1 } { #2 }
}

%%% Print the last attribute in a table (no NULL check, always prints)
%%% Usage: \spellattributelast{Duration}{1 round/level}
\NewDocumentCommand{\spellattributelast}{m m}
{
  \spellcard_attribute_last:nn { #1 } { #2 }
}

\ExplSyntaxOff

%%% Deck Query Commands
%%% Public interface for querying deck contents (for index generation)
\ExplSyntaxOn

%%% Register a spell manually in the current deck
%%% Usage: \registerspell{spells/sor/1/MagicMissile.tex}{sor}{Magic Missile}{1}
\NewDocumentCommand{\registerspell}{m m m m}
{
  \spellcard_register_spell:nnnn { #1 } { #2 } { #3 } { #4 }
}

%%% Get count of spells in a deck
%%% Usage: \deckspellcount{0} → prints number
\NewDocumentCommand{\deckspellcount}{m}
{
  \spellcard_get_deck_spell_count:n { #1 }
}

%%% Get total number of decks
%%% Usage: \deckcount → prints number
\NewDocumentCommand{\deckcount}{}
{
  \spellcard_get_deck_count:
}

%%% Show deck information (debugging)
%%% Usage: \showdeck{0}
\NewDocumentCommand{\showdeck}{m}
{
  \spellcard_show_deck:n { #1 }
}

\ExplSyntaxOff

%%% QR Code Command
%%% Modern interface for adding QR codes to spell cards
\ExplSyntaxOn

%%% Add a QR code to the current page
%%% Usage: \spellcardqr{https://example.com/spell/fireball}
%%% Maximum 2 QR codes per page (use \clearpage for more)
\NewDocumentCommand{\spellcardqr}{m}
{
  \spellcard_add_qr_code:n { #1 }
}

\ExplSyntaxOff

%% ============================================================================
%% Legacy Interface (will be removed in future phases)
%% ============================================================================
%% These commands provide compatibility with existing templates

%%% Legacy \noprint command for backwards compatibility
%%% New code should use \includespell[noprint]{...} instead
\ExplSyntaxOn
\NewDocumentCommand{\noprint}{m}
{
  % Save current print state
  \bool_set_eq:NN \l_tmpa_bool \g_spellcard_print_card_bool

  % Temporarily disable printing
  \bool_gset_false:N \g_spellcard_print_card_bool

  % Execute the code (typically \input{spellfile})
  #1

  % Restore previous print state
  \bool_gset_eq:NN \g_spellcard_print_card_bool \l_tmpa_bool
}
\ExplSyntaxOff

\endinput
%%
%% End of file `spellcard-expl3.sty'.
%%
