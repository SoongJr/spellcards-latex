%%
%% This is file `spellcard-expl3.sty'
%%
%% LaTeX3 (expl3) implementation for spell card generation
%% Modern replacement for traditional LaTeX2e macros
%%
%% Copyright (C) 2025 SoongJr
%% License: Open Source (see LICENSE file)
%%

\NeedsTeXFormat{LaTeX2e}
\ProvidesExplPackage
{spellcard-expl3}                    % Package name
{2025/10/25}                         % Release date
{1.0.0}                              % Version
{LaTeX3 implementation for spell cards} % Description

%% ============================================================================
%% Package Dependencies
%% ============================================================================

\RequirePackage{xparse}      % For \NewDocumentCommand and \NewDocumentEnvironment
\RequirePackage{tikz}         % For drawing markers and labels
\RequirePackage{qrcode}       % For QR code generation
\RequirePackage{booktabs}     % For table formatting
\RequirePackage{tabularx}     % For flexible tables
\RequirePackage{longtable}    % For multi-page tables

%% ============================================================================
%% expl3 Programming Environment
%% ============================================================================

\ExplSyntaxOn

%% ============================================================================
%% Module Configuration
%% ============================================================================
%% All internal functions and variables use the prefix: spellcard_
%% Naming conventions:
%%   - Functions: \spellcard_function_name:nn
%%   - Variables: \l_spellcard_variable_name_type or \g_spellcard_variable_name_type
%%   - Constants: \c_spellcard_constant_name_type
%%   - l_ prefix: local scope
%%   - g_ prefix: global scope
%%   - c_ prefix: constant (unchanging)

%% ============================================================================
%% Boolean Variables
%% ============================================================================
%% Modern replacements for \newif constructs

% Flag to control whether a spell card should be printed
% Replaces: \ifprintcard
\bool_new:N \g_spellcard_print_card_bool
\bool_gset_true:N \g_spellcard_print_card_bool

% Flag to detect nested spelldeck environments
% Used for validation to prevent nesting errors
\bool_new:N \g_spellcard_in_deck_bool
\bool_gset_false:N \g_spellcard_in_deck_bool

% Flag to track if printer margins are defined (from cardify.tex)
\bool_new:N \l_spellcard_has_printer_margin_bool
\bool_set_false:N \l_spellcard_has_printer_margin_bool

% Flag for includespell command options (whether to print)
\bool_new:N \l_spellcard_include_print_bool
\bool_set_true:N \l_spellcard_include_print_bool

%% ============================================================================
%% Integer Variables
%% ============================================================================
%% Modern replacements for \newcounter constructs

% Current deck number (0 = unnamed/main deck, 1+ = named decks)
% Replaces: \currentdecknumber counter
\int_new:N \g_spellcard_deck_number_int
\int_gzero:N \g_spellcard_deck_number_int

% QR code counter for tracking codes on current page (max 2)
% Replaces: \qrCode counter
\int_new:N \g_spellcard_qr_code_int
\int_gzero:N \g_spellcard_qr_code_int

% Current spell level for marker positioning
\int_new:N \l_spellcard_spell_level_int
\int_zero:N \l_spellcard_spell_level_int

%% ============================================================================
%% Token List Variables
%% ============================================================================
%% Modern replacements for \newcommand string macros

% Current deck name (empty for deck 0, non-empty for other decks)
% Replaces: \currentdeckname
\tl_new:N \l_spellcard_current_deck_name_tl
\tl_clear:N \l_spellcard_current_deck_name_tl

% Spell card properties - basic identification
\tl_new:N \l_spellcard_class_tl           % Character class (sor, wiz, etc.)
\tl_new:N \l_spellcard_name_tl            % Spell name
\tl_new:N \l_spellcard_school_tl          % School of magic
\tl_new:N \l_spellcard_subschool_tl       % Subschool if applicable
\tl_new:N \l_spellcard_descriptor_tl      % Spell descriptor

% Spell card properties - casting information
\tl_new:N \l_spellcard_casting_time_tl    % Casting time
\tl_new:N \l_spellcard_components_tl      % Components (V, S, M, F, DF)
\tl_new:N \l_spellcard_range_tl           % Range
\tl_new:N \l_spellcard_duration_tl        % Duration
\tl_new:N \l_spellcard_area_tl            % Area of effect
\tl_new:N \l_spellcard_effect_tl          % Effect
\tl_new:N \l_spellcard_targets_tl         % Targets

% Spell card properties - game mechanics
\tl_new:N \l_spellcard_saving_throw_tl    % Saving throw
\tl_new:N \l_spellcard_spell_resistance_tl % Spell resistance
\tl_new:N \l_spellcard_attack_roll_tl     % Attack roll

% URLs for QR codes
\tl_new:N \l_spellcard_url_english_tl     % Primary URL (English)
\tl_new:N \l_spellcard_url_secondary_tl   % Secondary URL (e.g., German)

% Temporary token lists for processing
\tl_new:N \l_spellcard_qr_code_content_tl % Content for QR code being generated
\tl_new:N \l_tmpa_spellcard_tl            % Temporary token list A
\tl_new:N \l_tmpb_spellcard_tl            % Temporary token list B

%% ============================================================================
%% Floating Point Variables
%% ============================================================================
%% For precise positioning calculations

% Marker positioning on right edge (spell level indicator)
\fp_new:N \l_spellcard_marker_position_fp
\fp_zero:N \l_spellcard_marker_position_fp

% Label positioning at top edge (deck name)
\fp_new:N \l_spellcard_label_position_fp
\fp_zero:N \l_spellcard_label_position_fp

% Printer margins (from cardify.tex)
\fp_new:N \l_spellcard_printer_margin_x_fp
\fp_new:N \l_spellcard_printer_margin_y_fp

% QR code positioning
\fp_new:N \l_spellcard_qr_shift_fp
\fp_zero:N \l_spellcard_qr_shift_fp

% Temporary floating point variables
\fp_new:N \l_tmpa_spellcard_fp
\fp_new:N \l_tmpb_spellcard_fp

%% ============================================================================
%% Dimension Variables
%% ============================================================================
%% For layout and spacing calculations

% Card dimensions
\dim_new:N \l_spellcard_card_width_dim
\dim_new:N \l_spellcard_card_height_dim

% Printer margins (converted from FP when needed)
\dim_new:N \l_spellcard_printer_margin_x_dim
\dim_new:N \l_spellcard_printer_margin_y_dim

% Positioning dimensions (calculated from FP)
\dim_new:N \l_spellcard_marker_position_dim
\dim_new:N \l_spellcard_label_position_dim
\dim_new:N \l_spellcard_qr_shift_dim

% Table widths for spell info
\dim_new:N \l_spellcard_first_table_width_dim
\dim_new:N \l_spellcard_second_table_width_dim

%% ============================================================================
%% Package Options
%% ============================================================================
%% Process package options for printer margins

%%% Define keys for package options
\keys_define:nn { spellcard }
{
  % Printer margin in X direction (horizontal)
  printer-margin-x .dim_set:N = \l_spellcard_printer_margin_x_dim,
  printer-margin-x .initial:n = 0pt,

  % Printer margin in Y direction (vertical)  
  printer-margin-y .dim_set:N = \l_spellcard_printer_margin_y_dim,
  printer-margin-y .initial:n = 0pt,

  % Convenience option to set both margins at once
  printer-margin .code:n =
    {
      \dim_set:Nn \l_spellcard_printer_margin_x_dim { #1 }
      \dim_set:Nn \l_spellcard_printer_margin_y_dim { #1 }
    },

  % Unknown option handler
  unknown .code:n =
    {
      \msg_error:nnxx { spellcard } { unknown-option }
      { \l_keys_key_str } { #1 }
    }
}

%%% Process package options
\ProcessKeyOptions [ spellcard ]

%% ============================================================================
%% Property Lists
%% ============================================================================
%% Structured data storage for spell properties

% Main property list for current spell's data
% This replaces the need for 60+ individual \newcommand definitions
\prop_new:N \l_spellcard_spell_props

%% ============================================================================
%% Sequences for Deck Tracking
%% ============================================================================
%% Track which spells belong to each deck for future index card generation

% Global property list: deck_number (as string) -> spell_list_sequence_name
% Each deck's sequence is dynamically created and stored here
\prop_new:N \g_spellcard_decks_prop

% Sequence for the current deck's spells (changes as we enter/exit decks)
% Each item is a property list containing spell metadata
\seq_new:N \g_spellcard_current_deck_spells_seq

% Temporary property list for storing individual spell metadata
\prop_new:N \l_spellcard_spell_metadata_prop

%% ============================================================================
%% Constants
%% ============================================================================

% Maximum QR codes per page
\int_const:Nn \c_spellcard_max_qr_codes_int { 2 }

% Maximum deck columns before wrapping
\int_const:Nn \c_spellcard_max_deck_columns_int { 6 }

% NULL value indicator (used in TSV data)
\tl_const:Nn \c_spellcard_null_value_tl { NULL }

% Marker spacing parameters
\fp_const:Nn \c_spellcard_marker_spacing_fp { 1/16 }
\fp_const:Nn \c_spellcard_marker_offset_fp { 2.5 }

% Label spacing parameters
\fp_const:Nn \c_spellcard_label_spacing_fp { 1/8 }

%% ============================================================================
%% Message System
%% ============================================================================
%% Modern error, warning, and info messages

%%% Package Configuration Errors
\msg_new:nnn { spellcard } { unknown-option }
{
  Unknown~package~option:~'#1'~with~value~'#2'.\\
  Valid~options~are:~printer-margin,~printer-margin-x,~printer-margin-y.
}

%%% Deck Management Errors
\msg_new:nnn { spellcard } { nested-decks }
{
  Nested~spell~decks~are~not~supported.\\
  You~may~have~forgotten~to~close~a~spelldeck~environment.
}

\msg_new:nnn { spellcard } { first-deck-must-be-unnamed }
{
  The~first~spell~deck~must~have~an~empty~name.\\
  Found~deck~name:~'\l_spellcard_current_deck_name_tl'
}

\msg_new:nnn { spellcard } { only-first-deck-unnamed }
{
  Only~the~first~spell~deck~may~have~an~empty~name.\\
  All~subsequent~decks~must~be~named.
}

%%% Spell File Errors
\msg_new:nnn { spellcard } { spell-file-not-found }
{
  Spell~file~not~found:~'#1'\\
  Check~that~the~file~path~is~correct~and~the~file~exists.
}

%%% Layout and Rendering Errors
\msg_new:nnn { spellcard } { too-many-qr-codes }
{
  Too~many~QR~codes~on~page~\int_use:N \c@page.\\
  Maximum~\int_use:N \c_spellcard_max_qr_codes_int~per~page.\\
  Consider~using~\token_to_str:N\clearpage~to~move~code~to~back~face.
}

%%% Data Completeness Warnings
%%% These warn about missing spell properties that may affect rendering

\msg_new:nnn { spellcard } { missing-school }
{
  Spell~'#1':~school~information~is~missing~or~NULL.\\
  This~property~is~required~for~proper~card~formatting.
}

\msg_new:nnn { spellcard } { missing-level }
{
  Spell~'#1':~level~information~is~missing.\\
  Spell~level~markers~cannot~be~drawn~without~this~property.
}

\msg_new:nnn { spellcard } { missing-components }
{
  Spell~'#1':~components~information~is~missing~or~NULL.\\
  Consider~specifying~at~least~'V',~'S',~or~'M'.
}

\msg_new:nnn { spellcard } { missing-casting-time }
{
  Spell~'#1':~casting~time~is~missing~or~NULL.\\
  Standard~action~is~a~common~default.
}

\msg_new:nnn { spellcard } { missing-duration }
{
  Spell~'#1':~duration~is~missing~or~NULL.\\
  This~is~important~tactical~information.
}

\msg_new:nnn { spellcard } { missing-range }
{
  Spell~'#1':~range~is~missing~or~NULL.\\
  Specify~'personal',~'touch',~or~a~distance.
}

%%% Data Quality Warnings
%%% These warn about potentially incorrect or unusual spell properties

\msg_new:nnn { spellcard } { empty-description }
{
  Spell~'#1':~description~appears~to~be~empty.\\
  This~will~result~in~a~nearly~blank~card.
}

\msg_new:nnn { spellcard } { all-targets-null }
{
  Spell~'#1':~area,~effect,~and~targets~are~all~NULL.\\
  At~least~one~of~these~should~be~specified.
}

\msg_new:nnn { spellcard } { suspicious-saving-throw }
{
  Spell~'#1':~saving~throw~is~'NULL'.\\
  Consider~using~'none'~if~no~save~is~allowed.
}

\msg_new:nnn { spellcard } { suspicious-spell-resistance }
{
  Spell~'#1':~spell~resistance~is~'NULL'.\\
  Consider~using~'no'~or~'yes'~explicitly.
}

\msg_new:nnn { spellcard } { inconclusive-attack-roll }
{
  Spell~'#1':~attack~roll~detection~inconclusive.\\
  Please~manually~set~to:~'ranged~touch',~'melee~touch',~'ranged',~'melee',~or~'\textbf{none}'.
}

%%% QR Code Issues
\msg_new:nnn { spellcard } { invalid-url }
{
  QR~code~URL~appears~malformed:~'#1'\\
  QR~codes~work~best~with~valid~http/https~URLs.
}

\msg_new:nnn { spellcard } { empty-qr-url }
{
  Spell~'#1':~QR~code~URL~is~empty~or~NULL.\\
  No~QR~code~will~be~generated~for~this~spell.
}

%%% Informational Messages
\msg_new:nnn { spellcard } { using-default-school }
{
  Spell~'#1':~using~default~school~'Universal'.
}

\msg_new:nnn { spellcard } { skipping-null-attribute }
{
  Spell~'#1':~skipping~NULL~attribute~'#2'.
}

%%% Deck Tracking Messages
\msg_new:nnn { spellcard } { spell-registered }
{
  Spell~'#1'~(level~#2)~registered~in~deck~#3.
}

\msg_new:nnn { spellcard } { deck-created }
{
  Created~deck~#1:~'#2'
}

\msg_new:nnn { spellcard } { spell-outside-deck }
{
  Warning:~Spell~'#1'~included~outside~of~any~deck.\\
  It~will~be~printed~but~not~tracked~for~index~generation.
}%% ============================================================================
%% Utility Functions
%% ============================================================================

%%% Check if printer margins are defined
%%% Priority order:
%%%   1. Package options (printer-margin-x, printer-margin-y)
%%%   2. External commands from cardify.tex (\printermarginx, \printermarginy)
%%%   3. Default to zero (no margins)
%%% Updates \l_spellcard_has_printer_margin_bool and FP variables
\cs_new:Nn \spellcard_check_printer_margins:
{
  % Check if margins were set via package options (non-zero dimensions)
  \bool_lazy_or:nnTF
  { \dim_compare_p:nNn { \l_spellcard_printer_margin_x_dim } > { 0pt } }
  { \dim_compare_p:nNn { \l_spellcard_printer_margin_y_dim } > { 0pt } }
  {
    % Package options were used - convert dimensions to FP
    \bool_set_true:N \l_spellcard_has_printer_margin_bool
    \fp_set:Nn \l_spellcard_printer_margin_x_fp
    { \dim_to_fp:n { \l_spellcard_printer_margin_x_dim } }
    \fp_set:Nn \l_spellcard_printer_margin_y_fp
    { \dim_to_fp:n { \l_spellcard_printer_margin_y_dim } }
  }
  {
    % Package options not used - check for external commands (backwards compatibility)
    \cs_if_exist:NTF \printermarginx
    {
      \bool_set_true:N \l_spellcard_has_printer_margin_bool
      \fp_set:Nn \l_spellcard_printer_margin_x_fp
      { \dim_to_fp:n { \printermarginx } }
      \fp_set:Nn \l_spellcard_printer_margin_y_fp
      { \dim_to_fp:n { \printermarginy } }
      % Also update dimension variables for consistency
      \dim_set:Nn \l_spellcard_printer_margin_x_dim { \printermarginx }
      \dim_set:Nn \l_spellcard_printer_margin_y_dim { \printermarginy }
    }
    {
      % No margins defined anywhere - use zero
      \bool_set_false:N \l_spellcard_has_printer_margin_bool
      \fp_zero:N \l_spellcard_printer_margin_x_fp
      \fp_zero:N \l_spellcard_printer_margin_y_fp
    }
  }
}%%% Check if a value is NULL (used for optional spell properties)
%%% \spellcard_if_not_null:nTF { value } { true-code } { false-code }
\prg_new_conditional:Npnn \spellcard_if_not_null:n #1 { p, T, F, TF }
{
  \str_if_eq:nnTF { #1 } { NULL }
  { \prg_return_false: }
  { \prg_return_true: }
}

%% ============================================================================
%% Positioning Calculations
%% ============================================================================
%%% Calculate marker position on right edge based on spell level
%%% #1 = spell level (0-9 for core spells, can be higher)
%%% Updates \l_spellcard_marker_position_dim
%%% Formula: ((1/16 * mod(level, 10)) * paperheight) + 2.5cm
\cs_new:Nn \spellcard_calculate_marker_position:n
{
  % Calculate modulo 10 to prevent overflow for levels > 9
  % Note: expl3 FP uses "mod" as an infix operator (x mod y), not a function
  \fp_set:Nn \l_tmpa_spellcard_fp { #1 - 10 * floor(#1 / 10) }

  % Calculate position: (1/16 * level_mod) * paperheight + 2.5cm
  \fp_set:Nn \l_spellcard_marker_position_fp
  {
    ( \c_spellcard_marker_spacing_fp * \l_tmpa_spellcard_fp )
    * \dim_to_fp:n { \paperheight }
    + \c_spellcard_marker_offset_fp cm
  }

  % Convert to dimension for TikZ usage
  \dim_set:Nn \l_spellcard_marker_position_dim
  { \fp_to_dim:N \l_spellcard_marker_position_fp }
}%%% Calculate label position at top edge based on deck number
%%% #1 = deck number (1-6, then wraps; 0 has no label)
%%% Updates \l_spellcard_label_position_dim
%%% Formula: ((1/8 * mod(deck-1, 6)) * paperwidth) + offset
%%% Offset is 7mm with printer margins, 15mm without
\cs_new:Nn \spellcard_calculate_label_position:n
{
  % Calculate modulo 6 for deck wrapping (deck-1 because deck 0 has no label)
  % Note: expl3 FP uses "mod" as an infix operator (x mod y), not a function
  \fp_set:Nn \l_tmpb_spellcard_fp { #1 - 1 }
  \fp_set:Nn \l_tmpa_spellcard_fp { \l_tmpb_spellcard_fp - 6 * floor(\l_tmpb_spellcard_fp / 6) }

  % Calculate base position: (1/8 * deck_mod) * paperwidth
  \fp_set:Nn \l_spellcard_label_position_fp
  {
    ( \c_spellcard_label_spacing_fp * \l_tmpa_spellcard_fp )
    * \dim_to_fp:n { \paperwidth }
  }

  % Add offset based on whether printer margins are defined
  \bool_if:NTF \l_spellcard_has_printer_margin_bool
  {
    % With printer margins: add 7mm offset
    \fp_add:Nn \l_spellcard_label_position_fp { 7mm }
  }
  {
    % Without printer margins: add 15mm offset
    \fp_add:Nn \l_spellcard_label_position_fp { 15mm }
  }

  % Convert to dimension for TikZ usage
  \dim_set:Nn \l_spellcard_label_position_dim
  { \fp_to_dim:N \l_spellcard_label_position_fp }
}

%%% Calculate marker x-shift based on printer margins
%%% Returns dimension for TikZ xshift
%%% With printer margins: -7mm
%%% Without printer margins: -12mm (-7mm - 5mm)
\cs_new:Nn \spellcard_get_marker_xshift:
{
  \bool_if:NTF \l_spellcard_has_printer_margin_bool
  { -7mm }
  { -12mm }
}

%%% Calculate marker guide width based on printer margins
%%% Returns dimension for TikZ line drawing
%%% With printer margins: 14mm
%%% Without printer margins: 19mm (14mm + 5mm)
\cs_new:Nn \spellcard_get_marker_guide_width:
{
  \bool_if:NTF \l_spellcard_has_printer_margin_bool
  { 14mm }
  { 19mm }
}

%%% Draw spell level marker on right edge of page
%%% #1 = spell level
\cs_new_protected:Npn \spellcard_draw_spell_marker:n #1
{
  % Calculate marker position
  \spellcard_calculate_marker_position:n { #1 }

  % Calculate marker positioning based on printer margins
  \dim_set:Nn \l_tmpa_dim
  {
    \bool_if:NTF \l_spellcard_has_printer_margin_bool
    { 7mm }
    { 12mm }
  }
  \dim_set:Nn \l_tmpb_dim
  {
    \bool_if:NTF \l_spellcard_has_printer_margin_bool
    { 14mm }
    { 19mm }
  }

  \begin{tikzpicture}[remember~ picture,~ overlay]
    % Draw the spell level number at the right edge
    \node [font=\Large, anchor=center,
      xshift=-\dim_use:N \l_tmpa_dim,
      yshift=-\l_spellcard_marker_position_dim]
    at~ (current~ page.north~ east) {\textbf{#1}};

    % Draw guide lines for highlighting
    \draw[lightgray, dotted, line~ width=1pt]
    (current~ page.north~ east)
    ++(0cm, -\l_spellcard_marker_position_dim + 8mm)
    -- ++(-\dim_use:N \l_tmpb_dim, 0)
    -- ++(0, -16mm)
    -- ++(\dim_use:N \l_tmpb_dim, 0);
  \end{tikzpicture}
}

%%% Draw deck label at top edge of page
%%% #1 = deck number, #2 = deck name
\cs_new_protected:Npn \spellcard_draw_deck_label:nn #1 #2
{
  % Deck 0 (unnamed deck) has no label
  \int_compare:nNnF { #1 } = { 0 }
    {
      % Calculate label position
      \spellcard_calculate_label_position:n { #1 }

      \begin{tikzpicture}[remember~ picture,~ overlay]
        % Draw deck name at top edge
        \node [font=\normalsize\itshape, anchor=west,
          xshift=\fp_to_dim:N \l_spellcard_label_position_fp,
          yshift=-\spellcard_get_label_yshift:]
        at~ (current~ page.north~ west) {#2};
      \end{tikzpicture}
    }
}

%%% Helper to get y-shift for deck label based on printer margins
\cs_new:Nn \spellcard_get_label_yshift:
{
  \bool_if:NTF \l_spellcard_has_printer_margin_bool
  { 7mm }
  { 15mm }
}

%% ============================================================================
%% Spell Card Rendering Functions
%% ============================================================================
%%% Functions for rendering spell information from property lists

%%% Helper to check if a property value is NULL or empty
\prg_new_conditional:Npnn \spellcard_is_null:n #1 { p, T, F, TF }
{
  \tl_set:Nx \l_tmpd_tl { \prop_item:Nn \l_spellcard_spell_props { #1 } }
  \tl_if_eq:NNTF \l_tmpd_tl \c_spellcard_null_value_tl
  { \prg_return_true: }
  {
    \tl_if_empty:NTF \l_tmpd_tl
    { \prg_return_true: }
    { \prg_return_false: }
  }
}

%%% Render a spell property row if not NULL (with midrule)
\cs_new:Npn \spellcard_render_if_not_null:nn #1 #2
{
  \spellcard_is_null:nF { #2 }
  {
    \textbf{#1:} & \prop_item:Nn \l_spellcard_spell_props { #2 } \\ \midrule
  }
}

%%% Render a spell property row if not NULL (with bottomrule, for last row)
\cs_new:Npn \spellcard_render_last_if_not_null:nn #1 #2
{
  \spellcard_is_null:nF { #2 }
  {
    \textbf{#1:} & \prop_item:Nn \l_spellcard_spell_props { #2 } \\ \bottomrule
  }
}

%%% Render the school row with optional descriptor
\cs_new:Npn \spellcard_render_school_row:
{
  \textbf{School:} &
  \prop_item:Nn \l_spellcard_spell_props { school }
  \spellcard_is_null:nF { descriptor }
  {
    ~ ( \prop_item:Nn \l_spellcard_spell_props { descriptor } )
  }
  \\ \bottomrule
}%%% Render target/effect table if either is non-NULL
\cs_new:Npn \spellcard_render_target_effect_table:
{
  % Check if both are NULL - if so, skip table entirely
  \bool_lazy_and:nnF
  { \spellcard_is_null:nT { targets } { \c_true_bool } }
  { \spellcard_is_null:nT { effect } { \c_true_bool } }
  {
    \\
    \begin{tabularx}{\textwidth}{r>{\raggedright\arraybackslash}X}
      \toprule
      \spellcard_is_null:nF { targets }
      {
      \textbf{Target:} & \prop_item:Nn \l_spellcard_spell_props { targets }
        \spellcard_is_null:nTF { effect }
      {                                                                     \\ \bottomrule }
      {                                                                     \\ \midrule }
      }
      \spellcard_is_null:nF { effect }
      {
      \textbf{Effect:} & \prop_item:Nn \l_spellcard_spell_props { effect }  \\ \bottomrule
      }
    \end{tabularx}
  }
}

%%% Helper function to add a row to a token list if property is not NULL
%%% #1 = property key
%%% #2 = label text
%%% #3 = row separator (spacing after row)
%%% #4 = target token list variable
\cs_new_protected:Npn \spellcard_add_row_if_not_null:nnnN #1 #2 #3 #4
{
\spellcard_is_null:nF { #1 }
{
\tl_set:Nx \l_tmpc_tl { \prop_item:Nn \l_spellcard_spell_props { #1 } }
\tl_put_right:Nn #4 { \textbf{#2} ~ & ~ }
\tl_put_right:No #4 { \l_tmpc_tl }
\tl_put_right:Nn #4 { ~ \\ [1pt] }
}
}

%%% Internal function to render spell card info
%%% Uses the pattern from expl3-code-with-tabularx.tex to build table content
%%% before passing it to tabularx
\cs_new_protected:Npn \spellcard_render_info:n #1
{
\group_begin:

\normalsize
\noindent

% Build LEFT table content (no rules, just rows)
\tl_clear:N \l_tmpa_tl
\spellcard_add_row_if_not_null:nnnN { castingtime } { Casting~Time: } {} \l_tmpa_tl
\spellcard_add_row_if_not_null:nnnN { savingthrow } { Saving~Throw: } {} \l_tmpa_tl
\spellcard_add_row_if_not_null:nnnN { spellresistance } { Spell~Resist: } {} \l_tmpa_tl
\spellcard_add_row_if_not_null:nnnN { attackroll } { Attack~Roll: } {} \l_tmpa_tl

% Build RIGHT table content (no rules, just rows)
\tl_clear:N \l_tmpb_tl
\spellcard_add_row_if_not_null:nnnN { duration } { Duration: } {} \l_tmpb_tl
\spellcard_add_row_if_not_null:nnnN { area } { Area: } {} \l_tmpb_tl
\spellcard_add_row_if_not_null:nnnN { range } { Range: } {} \l_tmpb_tl
\spellcard_add_row_if_not_null:nnnN { components } { Comp.: } {} \l_tmpb_tl

% School row (always present) with optional descriptor
% Special handling: only show descriptor for evocation school (matches legacy)
\tl_put_right:Nn \l_tmpb_tl { \textbf{School:} ~ & ~ }
\tl_set:Nx \l_tmpc_tl { \prop_item:Nn \l_spellcard_spell_props { school } }
\tl_put_right:No \l_tmpb_tl { \l_tmpc_tl }
% Check if school is "evocation" AND descriptor is not NULL
\tl_set:Nx \l_tmpd_tl { \prop_item:Nn \l_spellcard_spell_props { school } }
\tl_if_eq:NnT \l_tmpd_tl { evocation }
{
  \spellcard_is_null:nF { descriptor }
  {
    \tl_put_right:Nn \l_tmpb_tl { ~ ( }
    \tl_set:Nx \l_tmpc_tl { \prop_item:Nn \l_spellcard_spell_props { descriptor } }
    \tl_put_right:No \l_tmpb_tl { \l_tmpc_tl }
    \tl_put_right:Nn \l_tmpb_tl { ) }
  }
}
\tl_put_right:Nn \l_tmpb_tl { ~ \\ }% Calculate widths outside of \use:x
\dim_set:Nn \l_tmpa_dim { #1 \textwidth }
\fp_set:Nn \l_tmpa_fp { 1 - #1 }
\dim_set:Nn \l_tmpb_dim { \fp_use:N \l_tmpa_fp \textwidth - \tabcolsep }

% Render left and right tables with pre-built content
\begin{tabularx}{\dim_use:N \l_tmpa_dim}{r>{\raggedright\arraybackslash}X}
  \tl_use:N \l_tmpa_tl
\end{tabularx}
\hfill
\begin{tabularx}{\dim_use:N \l_tmpb_dim}{r>{\raggedright\arraybackslash}X}
  \tl_use:N \l_tmpb_tl
\end{tabularx}

% Third table for Target/Effect (if either exists)
\bool_set_false:N \l_tmpa_bool
\spellcard_is_null:nF { targets } { \bool_set_true:N \l_tmpa_bool }
\spellcard_is_null:nF { effect } { \bool_set_true:N \l_tmpa_bool }
\bool_if:NT \l_tmpa_bool
{
\tl_clear:N \l_tmpa_tl
\spellcard_add_row_if_not_null:nnnN { targets } { Target: } {} \l_tmpa_tl
\spellcard_add_row_if_not_null:nnnN { effect } { Effect: } {} \l_tmpa_tl

\\
\use:x
{
  \exp_not:n { \begin{tabularx} }
      { \textwidth }
      { r>{\raggedright\arraybackslash}X }
      }
      \tl_use:N \l_tmpa_tl
    \end{tabularx}
  }

  \group_end:

  \vspace{1ex}

  \raggedright\Large
}

%% ============================================================================
%% QR Code Management System
%% ============================================================================
%%% Modern replacement for \spellcardqr command using expl3
%%% Validates QR code count, calculates positioning based on page parity
%%% and QR code number, then renders using TikZ

%%% Calculate QR code shift based on QR code number
%%% First QR code (index 0): 2cm - placed opposite page number
%%% Second QR code (index 1): 4cm - needs space for page number
%%% Stores result in \l_spellcard_qr_shift_dim
\cs_new:Nn \spellcard_calculate_qr_shift:
{
  \int_compare:nNnTF { \g_spellcard_qr_code_int } = { 0 }
    {
      \dim_set:Nn \l_spellcard_qr_shift_dim { 2cm }
    }
    {
      \dim_set:Nn \l_spellcard_qr_shift_dim { 4cm }
    }
}

%%% Place QR code at south west corner
%%% #1 = QR code content
\cs_new:Nn \spellcard_place_qr_southwest:n
{
  \begin{tikzpicture}[remember~picture,~overlay]
    \node [anchor=south~west,~xshift=\l_spellcard_qr_shift_dim,~yshift=1cm]
    at~(current~page.south~west) { \qrcode{#1} };
  \end{tikzpicture}
}

%%% Place QR code at south east corner
%%% #1 = QR code content
\cs_new:Nn \spellcard_place_qr_southeast:n
{
  \begin{tikzpicture}[remember~picture,~overlay]
    \node [anchor=south~east,~xshift=-\l_spellcard_qr_shift_dim,~yshift=1cm]
    at~(current~page.south~east) { \qrcode{#1} };
  \end{tikzpicture}
}

%%% Process QR code placement on odd pages (page number on right)
%%% #1 = QR code content
\cs_new:Nn \spellcard_qr_code_odd_page:n
{
  \int_case:nn { \g_spellcard_qr_code_int }
  {
    { 0 } { \spellcard_place_qr_southwest:n { #1 } }  % First code: left side
      { 1 } { \spellcard_place_qr_southeast:n { #1 } }  % Second code: right side
  }
}

%%% Process QR code placement on even pages (page number on left)
%%% #1 = QR code content
\cs_new:Nn \spellcard_qr_code_even_page:n
{
  \int_case:nn { \g_spellcard_qr_code_int }
  {
    { 0 } { \spellcard_place_qr_southeast:n { #1 } }  % First code: right side
      { 1 } { \spellcard_place_qr_southwest:n { #1 } }  % Second code: left side
  }
}

%%% Add QR code to current page
%%% #1 = QR code content (URL or text)
%%% Validates maximum 2 codes per page
%%% Calculates position based on page parity and QR code number
\cs_new:Nn \spellcard_add_qr_code:n
{
  % Validate: maximum 2 QR codes per page
  \int_compare:nNnT { \g_spellcard_qr_code_int } > { 1 }
    {
      \msg_error:nn { spellcard } { too-many-qr-codes }
    }

  % Calculate shift distance based on QR code number
  \spellcard_calculate_qr_shift:

  % Place QR code based on page parity
  \int_if_odd:nTF { \value{page} }
  {
    \spellcard_qr_code_odd_page:n { #1 }
  }
  {
    \spellcard_qr_code_even_page:n { #1 }
  }

  % Increment QR code counter
  \int_gincr:N \g_spellcard_qr_code_int
}

%%% Reset QR code counter
%%% Called at the start of each spell card environment
%%% Can also be called manually with \clearpage for testing
\cs_new:Nn \spellcard_reset_qr_counter:
{
  \int_gzero:N \g_spellcard_qr_code_int
}

%% ============================================================================
%% Conditional Logic for Spell Attributes
%% ============================================================================

%%% Print spell attribute only if value is not NULL
%%% #1 = attribute name (label)
%%% #2 = attribute value (content)
%%% Replaces: \ifthenelse{\equal{#2}{NULL}}{}{\textbf{#1:} & #2 \\ \midrule}
\cs_new:Nn \spellcard_attribute:nn
{
  \spellcard_if_not_null:nT { #2 }
  {
    \textbf{#1:} & #2 \\ \midrule
  }
}

%%% Print last spell attribute (always printed, no NULL check)
%%% #1 = attribute name (label)
%%% #2 = attribute value (content)
%%% Replaces: \textbf{#1:} & #2 \\ \bottomrule
\cs_new:Nn \spellcard_attribute_last:nn
{
  \textbf{#1:} & #2 \\ \bottomrule
}

%% ============================================================================
%% Deck Management System
%% ============================================================================

%%% Begin a spell deck
%%% Updates current deck state variables and initializes spell tracking
\cs_new:Nn \spellcard_deck_begin:n
{
% Check for nested decks (error if we're already in a deck)
\bool_if:NTF \g_spellcard_in_deck_bool
{
  \msg_error:nn { spellcard } { nested-decks }
}
{
  % Mark that we're now in a deck
  \bool_gset_true:N \g_spellcard_in_deck_bool
}

% Validate deck naming rules BEFORE setting the name
\int_compare:nNnTF { \g_spellcard_deck_number_int } = { 0 }
{
% First deck must be unnamed
\tl_if_empty:nF { #1 }
{
  \msg_error:nn { spellcard } { first-deck-must-be-unnamed }
}
}
{
% Subsequent decks must be named
\tl_if_empty:nT { #1 }
{
  \msg_error:nn { spellcard } { only-first-deck-unnamed }
}
}

% Set the new deck name (after validation)
\tl_set:Nn \l_spellcard_current_deck_name_tl { #1 }

% Initialize spell tracking for this deck
\seq_gclear:N \g_spellcard_current_deck_spells_seq
}

%%% End a spell deck
%%% Increments deck counter, stores spell list, and clears current deck name
\cs_new:Nn \spellcard_deck_end:
{
  % Store the deck's spell list in the global registry
  % Create a unique sequence for this deck number
  \cs_if_exist:cF { g_spellcard_deck_ \int_use:N \g_spellcard_deck_number_int _spells_seq }
  {
    \seq_new:c { g_spellcard_deck_ \int_use:N \g_spellcard_deck_number_int _spells_seq }
  }

  % Copy current deck's spells to the permanent deck sequence
  \seq_gset_eq:cN { g_spellcard_deck_ \int_use:N \g_spellcard_deck_number_int _spells_seq }
  \g_spellcard_current_deck_spells_seq

  % Store metadata about this deck in property list
  % Format: "deck_N" -> "name={...},count=N"
  \tl_set:Nx \l_tmpa_spellcard_tl
  {
    name={\tl_use:N \l_spellcard_current_deck_name_tl},
    count={\int_eval:n { \seq_count:N \g_spellcard_current_deck_spells_seq }}
  }
  \prop_gput:NVn \g_spellcard_decks_prop
  \l_tmpa_spellcard_tl
  { \tl_use:N \l_tmpa_spellcard_tl }

  % Increment the global deck counter
  \int_gincr:N \g_spellcard_deck_number_int

  % Clear the current deck name to mark we're outside a deck
  \tl_clear:N \l_spellcard_current_deck_name_tl

  % Mark that we're no longer in a deck
  \bool_gset_false:N \g_spellcard_in_deck_bool
}

%% ============================================================================
%% Spell Registration System
%% ============================================================================

%%% Register a spell in the current deck's spell list
%%% #1 = spell file path
%%% #2 = spell class (e.g., "sor", "wiz")
%%% #3 = spell name
%%% #4 = spell level
\cs_new:Nn \spellcard_register_spell:nnnn
{
  % Only register if we're inside a deck
  \tl_if_empty:NF \l_spellcard_current_deck_name_tl
  {
    % Create a property list for this spell's metadata
    \prop_clear:N \l_spellcard_spell_metadata_prop
    \prop_put:Nnn \l_spellcard_spell_metadata_prop { file } { #1 }
    \prop_put:Nnn \l_spellcard_spell_metadata_prop { class } { #2 }
    \prop_put:Nnn \l_spellcard_spell_metadata_prop { name } { #3 }
    \prop_put:Nnn \l_spellcard_spell_metadata_prop { level } { #4 }
    \prop_put:Nnx \l_spellcard_spell_metadata_prop { deck }
    { \int_use:N \g_spellcard_deck_number_int }

    % Serialize the property list to a token list for storage
    % Format: "file={...},class={...},name={...},level={...}"
    \tl_set:Nx \l_tmpa_spellcard_tl
    {
      file={#1},class={#2},name={#3},level={#4}
    }

    % Add to current deck's spell sequence
    \seq_gput_right:NV \g_spellcard_current_deck_spells_seq \l_tmpa_spellcard_tl
  }
}

%%% Extract spell information from file path
%%% Path format: spells/{class}/{level}/{SpellName}.tex
%%% Sets \l_tmpa_spellcard_tl = class, \l_tmpb_spellcard_tl = level, 
%%% \l_spellcard_name_tl = spell name
\cs_new:Nn \spellcard_parse_spell_path:n
{
  % Extract class (between first and second /)
  \tl_set:Nn \l_tmpa_spellcard_tl { #1 }

  % Simple extraction: split on / and get components
  % This is a simplified version - full implementation would use regex
  % For now, we'll extract what we can from the path pattern
  % TODO: Implement full path parsing with regex
}

%% ============================================================================
%% Deck Query Functions
%% ============================================================================
%% Functions to query deck contents - useful for index card generation

%%% Get the number of spells in a specific deck
%%% #1 = deck number
%%% Returns: integer count
\cs_new:Nn \spellcard_get_deck_spell_count:n
{
  \seq_count:c { g_spellcard_deck_ #1 _spells_seq }
}

%%% Get the total number of decks created
\cs_new:Nn \spellcard_get_deck_count:
{
  \int_use:N \g_spellcard_deck_number_int
}

%%% Check if a deck exists
%%% #1 = deck number
\prg_new_conditional:Npnn \spellcard_if_deck_exists:n #1 { p, T, F, TF }
{
  \cs_if_exist:cTF { g_spellcard_deck_ #1 _spells_seq }
  { \prg_return_true: }
  { \prg_return_false: }
}

%%% Map a function over all spells in a deck
%%% #1 = deck number
%%% #2 = inline function to apply to each spell metadata string
%%% Each spell is passed as: file={...},class={...},name={...},level={...}
\cs_new:Nn \spellcard_map_deck_spells:nn
{
  \spellcard_if_deck_exists:nTF { #1 }
  {
    \seq_map_inline:cn { g_spellcard_deck_ #1 _spells_seq } { #2 }
  }
  {
    \msg_warning:nnn { spellcard } { deck-not-found } { #1 }
  }
}

%%% Count spells of a specific level in a deck
%%% #1 = deck number
%%% #2 = spell level to count
\cs_new:Nn \spellcard_count_spells_by_level:nn
{
  \int_zero:N \l_tmpa_int
  \spellcard_map_deck_spells:nn { #1 }
  {
    % Parse the metadata string to check level
    % This is simplified - full implementation would parse the key-value pairs
    \tl_if_in:nnT { ##1 } { level={#2} }
  {
    \int_incr:N \l_tmpa_int
  }
}
\int_use:N \l_tmpa_int
}

%%% Export deck spell list to console (debugging/verification)
%%% #1 = deck number
\cs_new:Nn \spellcard_show_deck:n
{
  \spellcard_if_deck_exists:nTF { #1 }
  {
    \msg_info:nnx { spellcard } { deck-info }
    {
      Deck~#1~contains~\spellcard_get_deck_spell_count:n { #1 }~spells
    }
    \spellcard_map_deck_spells:nn { #1 }
    {
      \msg_info:nnn { spellcard } { spell-info } { ##1 }
    }
  }
  {
    \msg_warning:nnn { spellcard } { deck-not-found } { #1 }
  }
}

%% Add messages for deck queries
\msg_new:nnn { spellcard } { deck-not-found }
{
  Deck~#1~does~not~exist~or~has~not~been~created~yet.
}

\msg_new:nnn { spellcard } { deck-info }
{
  #1
}

\msg_new:nnn { spellcard } { spell-info }
{
  ~~-~#1
}

%% ============================================================================
%% Print Control System
%% ============================================================================

%%% Keys for spell inclusion options
\keys_define:nn { spellcard / includespell }
{
  % Whether to print the spell card (default: true)
  print .bool_set:N = \l_spellcard_include_print_bool,
  print .initial:n = true,
  print .default:n = true,

  % Alias: noprint sets print to false
  noprint .bool_set_inverse:N = \l_spellcard_include_print_bool,
  noprint .default:n = true,
}

%%% Internal function to include a spell file with options
%%% #1 = file path (relative to document root)
\cs_new:Nn \spellcard_include_spell:n
{
  % Save current print state
  \bool_set_eq:NN \l_tmpa_bool \g_spellcard_print_card_bool

  % Apply the print option (already set by keys_set in the caller)
  \bool_gset_eq:NN \g_spellcard_print_card_bool \l_spellcard_include_print_bool

  % Check if file exists before including
  \file_if_exist:nTF { #1 }
  {
    \file_input:n { #1 }
  }
  {
    \msg_error:nnn { spellcard } { spell-file-not-found } { #1 }
  }

  % Restore previous print state
  \bool_gset_eq:NN \g_spellcard_print_card_bool \l_tmpa_bool
}

%% ============================================================================
%% Initialization
%% ============================================================================

% Check for printer margins at package load
\AtBeginDocument
{
  \spellcard_check_printer_margins:
}

%% ============================================================================
%% End of expl3 Programming Environment
%% ============================================================================

\ExplSyntaxOff

%% ============================================================================
%% Document-Level Interface (LaTeX2e compatibility)
%% ============================================================================

%%% Spell Deck Environment
%%% Usage: 
%%%   Without cardify: \begin{spelldeck} ... or \begin{spelldeck}[name]
%%%   With cardify:    \begin{spelldeck}{} ... or \begin{spelldeck}{name}
%%% First deck must have empty name, subsequent decks must be named
\ExplSyntaxOn
\NewDocumentEnvironment{spelldeck}{O{} G{}}
{
  % If optional bracket arg provided, use it; otherwise use mandatory brace arg (or default empty)
  \tl_if_empty:nTF {#1}
  { \spellcard_deck_begin:n { #2 } }
  { \spellcard_deck_begin:n { #1 } }
}
{
  \spellcard_deck_end:
}
\ExplSyntaxOff

%%% Spell Inclusion Command
%%% Usage: 
%%%   \includespell{spells/sor/1/MagicMissile}           % print the spell
%%%   \includespell[noprint]{spells/sor/1/MagicMissile}  % include without printing
%%%   \includespell[print=false]{spells/sor/1/MagicMissile}  % same as noprint
\ExplSyntaxOn
\NewDocumentCommand{\includespell}{O{} m}
{
  % Reset print option to default (true) before processing keys
  \bool_set_true:N \l_spellcard_include_print_bool

  % Process options (may override the default)
  \keys_set:nn { spellcard / includespell } { #1 }

  % Include the spell file
  \spellcard_include_spell:n { #2 }
}
\ExplSyntaxOff

%%% Spell Attribute Commands
%%% Modern interface for printing spell attributes with NULL checking
\ExplSyntaxOn

%%% Print a spell attribute (skips if NULL)
%%% Usage: \spellattribute{Range}{25 ft + 5 ft/2 levels}
\NewDocumentCommand{\spellattribute}{m m}
{
  \spellcard_attribute:nn { #1 } { #2 }
}

%%% Print the last attribute in a table (no NULL check, always prints)
%%% Usage: \spellattributelast{Duration}{1 round/level}
\NewDocumentCommand{\spellattributelast}{m m}
{
  \spellcard_attribute_last:nn { #1 } { #2 }
}

\ExplSyntaxOff

%%% Deck Query Commands
%%% Public interface for querying deck contents (for index generation)
\ExplSyntaxOn

%%% Register a spell manually in the current deck
%%% Usage: \registerspell{spells/sor/1/MagicMissile.tex}{sor}{Magic Missile}{1}
\NewDocumentCommand{\registerspell}{m m m m}
{
  \spellcard_register_spell:nnnn { #1 } { #2 } { #3 } { #4 }
}

%%% Get count of spells in a deck
%%% Usage: \deckspellcount{0} → prints number
\NewDocumentCommand{\deckspellcount}{m}
{
  \spellcard_get_deck_spell_count:n { #1 }
}

%%% Get total number of decks
%%% Usage: \deckcount → prints number
\NewDocumentCommand{\deckcount}{}
{
  \spellcard_get_deck_count:
}

%%% Show deck information (debugging)
%%% Usage: \showdeck{0}
\NewDocumentCommand{\showdeck}{m}
{
  \spellcard_show_deck:n { #1 }
}

\ExplSyntaxOff

%%% QR Code Command
%%% Modern interface for adding QR codes to spell cards
\ExplSyntaxOn

%%% Add a QR code to the current page
%%% Usage: \spellcardqr{https://example.com/spell/fireball}
%%% Maximum 2 QR codes per page (use \clearpage for more)
\NewDocumentCommand{\spellcardqr}{m}
{
  \spellcard_add_qr_code:n { #1 }
}

%%% Set a spell property (used within spell files)
%%% Usage: \spellprop{school}{evocation}
\NewDocumentCommand{\spellprop}{mm}
{
  \prop_put:Nnn \l_spellcard_spell_props { #1 } { #2 }
}

%%% Document-level command wrapper
%%% This is tricky: the command must work when called from normal LaTeX mode
%%% (inside spell file bodies), but execute expl3 code internally.
%%% We define it while ExplSyntax is ON, which means when it's *called* from
%%% normal mode, LaTeX will look up the already-defined command (which contains
%%% expl3 tokens with the correct catcodes baked in at definition time).
\NewDocumentCommand{\spellcardinfo}{O{0.5}}
{
  % At this point we're executing the command body, which was tokenized
  % during definition (while ExplSyntax was ON), so all the expl3 commands
  % here have the correct catcodes.
  \spellcard_render_info:n { #1 }
}

\ExplSyntaxOff

%%% Spell card environment
%%% Usage: \begin{spellcard}{class}{name}{level} ... \end{spellcard}
%%% This environment renders a complete spell card from property list data
\ExplSyntaxOn
\NewDocumentEnvironment{spellcard}{mmm+b}
{
  % Clear property list for this spell
  \prop_clear:N \l_spellcard_spell_props

  % Store basic spell metadata
  \tl_set:Nn \l_spellcard_class_tl { #1 }
  \tl_set:Nn \l_spellcard_name_tl { #2 }
  \int_set:Nn \l_spellcard_spell_level_int { #3 }

  % Render title and decorative elements
  \bool_if:NT \g_spellcard_print_card_bool
  {
    \section*{\Huge #2 \hfill \MakeUppercase{#1}~#3}
    \spellcard_draw_deck_label:nn
    { \int_use:N \g_spellcard_deck_number_int }
    { \tl_use:N \l_spellcard_current_deck_name_tl }
    \spellcard_draw_spell_marker:n { #3 }
  }

  % Only execute body if printing
  \bool_if:NT \g_spellcard_print_card_bool
  {
    #4  % The body captured by +b
  }
}
{
  % End of spell card
  \bool_if:NT \g_spellcard_print_card_bool
  {
    \clearcard
  }

  % Reset counters
  \setcounter{page}{1}
  \setcounter{table}{0}
  \setcounter{figure}{0}
  \spellcard_reset_qr_counter:
}
\ExplSyntaxOff

%% ============================================================================
%% Legacy Interface (will be removed in future phases)
%% ============================================================================
%% These commands provide compatibility with existing templates

%%% Legacy \noprint command for backwards compatibility
%%% New code should use \includespell[noprint]{...} instead
\ExplSyntaxOn
\NewDocumentCommand{\noprint}{m}
{
  % Save current print state
  \bool_set_eq:NN \l_tmpa_bool \g_spellcard_print_card_bool

  % Temporarily disable printing
  \bool_gset_false:N \g_spellcard_print_card_bool

  % Execute the code (typically \input{spellfile})
  #1

  % Restore previous print state
  \bool_gset_eq:NN \g_spellcard_print_card_bool \l_tmpa_bool
}

%% ============================================================================
%% Legacy Compatibility Exports
%% ============================================================================
%% Provide LaTeX2e-style access to expl3 internal state for legacy templates
\ExplSyntaxOff

% Export deck number as a LaTeX counter
\newcounter{currentdecknumber}
\ExplSyntaxOn
% Sync the counter value with expl3 variable after each deck operation
\cs_set_eq:NN \spellcard_original_deck_end: \spellcard_deck_end:
\cs_set:Npn \spellcard_deck_end:
{
  \spellcard_original_deck_end:
  \setcounter{currentdecknumber}{\int_use:N \g_spellcard_deck_number_int}
}
\ExplSyntaxOff

% Export deck name as a LaTeX macro
\providecommand{\currentdeckname}{}
\ExplSyntaxOn
\cs_set_eq:NN \spellcard_original_deck_begin:n \spellcard_deck_begin:n
\cs_set:Npn \spellcard_deck_begin:n #1
{
  \spellcard_original_deck_begin:n { #1 }
  \tl_set_eq:NN \currentdeckname \l_spellcard_current_deck_name_tl
}
\ExplSyntaxOff

% Export print card flag
\newif\ifprintcard
\ExplSyntaxOn
\AtBeginDocument{
  \bool_if:NTF \g_spellcard_print_card_bool
  { \printcardtrue }
  { \printcardfalse }
}
\ExplSyntaxOff

% Export QR code counter as a LaTeX counter
% This allows legacy templates to use \setcounter{qrCode}{0} instead of expl3 functions
\newcounter{qrCode}
\ExplSyntaxOn
% Keep the counter synchronized with the expl3 variable in both directions
% Hook into the increment function to update LaTeX2e counter
\cs_set_eq:NN \spellcard_original_increment_qr: \spellcard_increment_qr_code:
\cs_set:Npn \spellcard_increment_qr_code:
{
  \spellcard_original_increment_qr:
  \setcounter{qrCode}{\int_use:N \g_spellcard_qr_code_int}
}

% Create a user-facing command that resets both counters
% This MUST be created with ExplSyntaxOn active, then exported
\cs_new_protected:Npn \spellcard_user_reset_qr:
{
  \int_gzero:N \g_spellcard_qr_code_int
  \setcounter{qrCode}{0}
}

% Export as LaTeX2e command (must be done OUTSIDE ExplSyntax mode)
\cs_new_eq:NN \resetqrcounter \spellcard_user_reset_qr:

\ExplSyntaxOff

\endinput
%%
%% End of file `spellcard-expl3.sty'.
%%
